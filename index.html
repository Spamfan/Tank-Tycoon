<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tank Tycoon (Pre-Alpha 4.6)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&display=swap');
        /* --- Base Styles --- */
        html, body { height: 100%; width: 100%; overflow: hidden; margin: 0; padding: 0; background-color: #2D3748; }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #F7FAFC;
            touch-action: none;
        }
        /* --- Start/Loading Screen --- */
        #start-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #2D3748; display: flex; flex-direction:column; justify-content: center; align-items: center; z-index: 200; color: white; transition: opacity 0.5s ease-out; }
        #splash-image { max-width: 67.5%; max-height: 52.5%; border-radius: 1rem; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
        #loading-text { margin-top: 2rem; font-size: 24px; display: none; }
        .loader { border: 8px solid #f3f3f3; border-top: 8px solid #16a34a; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; margin-bottom: 1rem; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #version-display { position: absolute; top: 10px; left: 10px; font-size: 14px; color: rgba(255,255,255,0.7); }
        .start-button-container { display: none; margin-top: 2rem; display: flex; flex-direction: column; gap: 1rem; }
        .start-btn { padding: 20px 40px; font-size: 24px; background: #16a34a; border: 2px solid white; border-radius: 10px; cursor: pointer; transition: background-color 0.2s; }
        .start-btn:hover { background: #22c55e; }
        
        /* --- Layout --- */
        .game-wrapper { display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; height: 100%; }
        #game-version-display { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); color: white; font-size: 12px; text-shadow: 1px 1px 2px black; z-index: 10; display: block; }
        
        .desktop-view #game-container, .desktop-view #gameCanvas { width: 100vw; height: 100vh; max-width: 100%; max-height: 100%; border-radius: 0; }
        .desktop-view .desktop-header { display: flex; position: fixed; top: 0; left: 0; width: 100%; justify-content: space-between; align-items: center; padding: 8px 16px; box-sizing: border-box; z-index: 10; pointer-events: none; }
        .mobile-view .desktop-header { display: none; }
        .desktop-view .header-left, .desktop-view .header-right { pointer-events: auto; display: flex; align-items: center; gap: 1rem; }
        .desktop-view .header-right { background: rgba(0, 0, 0, 0.3); padding: 8px 12px; border-radius: 8px; }
        
        canvas { display: block; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.2); flex-shrink: 0; image-rendering: pixelated; }
        .mobile-view .ui-container { position: fixed; top: 10px; right: 10px; display: flex; align-items: center; gap: 1rem; background: rgba(0, 0, 0, 0.3); padding: 8px 12px; border-radius: 8px; z-index: 10; }
        
        #health-display, #money-display, #ammo-display, #blueprint-display {
            font-size: 18px;
            font-weight: 700;
            transition: transform 0.2s, color 0.2s;
            text-shadow: 1px 1px 2px black;
        }
        #health-display { color: #ef4444; }
        #money-display { color: #fbbf24; }
        #ammo-display { color: #f9fafb; display: none; }
        #blueprint-display { display: none; gap: 0.5rem; }

        #debug-panel, #ping-spy-panel { position: fixed; background: rgba(0,0,0,0.7); color: white; font-family: monospace; padding: 5px; border-radius: 5px; z-index: 200; display: none; }
        #debug-panel { top: 50px; left: 10px; font-size: 12px; }
        #ping-spy-panel { bottom: 10px; left: 10px; font-size: 10px; }
        
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: none; justify-content: center; align-items: center; flex-direction: column; z-index: 100; text-align: center; }
        .modal-content { background: #4A5568; padding: 1.5rem; border-radius: 1rem; border: 2px solid #2D3748; display: flex; flex-direction: column; gap: 1rem; align-items: center; max-height: 80%; overflow-y: auto; width: 90%; max-width: 500px; }
        .modal-button { padding: 12px 24px; font-size: 18px; background: #b91c1c; border: 2px solid white; border-radius: 10px; cursor: pointer; transition: background-color 0.2s; }
        .modal-button:hover { filter: brightness(1.1); }
        .confirm-button { background: #16a34a; }
        #resume-btn { transform: scale(1.3); } /* Y1.6 Make Resume bigger */
        .info-button { background: #1e3a8a; } /* Y1.6 Navy Blue */
        .admin-button-color { background: #38bdf8; } /* Y1.6 Sky Blue */
        
        /* Y1.6 Audio Toggle Styles */
        .audio-toggle { display: flex; align-items: center; justify-content: center; cursor: pointer; padding: 12px 24px; font-size: 18px; border: 2px solid white; border-radius: 10px; user-select: none; gap: 0.5rem; }
        .audio-toggle-label { font-weight: bold; }
        .audio-toggle-option { padding: 4px 12px; border-radius: 6px; border: 2px solid transparent; }
        .audio-toggle-option.active { background-color: #16a34a; border-color: white; }
		#pause-btn { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; cursor: pointer; position: fixed; top: 10px; z-index: 10; }
        .mobile-view #pause-btn { left: 10px; }
        .desktop-view #pause-btn { left: 16px; } /* Aligns with desktop header padding */
        
        #achievement-notification { position: fixed; background: rgba(45, 55, 72, 0.9); color: white; padding: 8px 12px; border-radius: 5px; z-index: 9; font-size: 14px; opacity: 0; display: flex; align-items: center; gap: 8px; transition: transform 0.5s ease-out, opacity 0.5s ease-out; white-space: nowrap; }
        .mobile-view #achievement-notification { transform: translateY(-120%); }
        .desktop-view #achievement-notification { top: 10px; left: 50%; transform: translate(-50%, -120%); z-index: 101; }
        #transition-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 199; opacity: 0; pointer-events: none; transition: opacity 0.5s ease-in-out; }

        .utility-btn { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 5px; cursor: pointer; font-size: 20px; width: 44px; text-align: center; }
        .utility-btn:hover { background: rgba(255,255,255,0.1); }
        .desktop-view #utility-buttons { position: fixed; top: 80px; right: 10px; z-index: 10; display: flex; flex-direction: column; gap: 8px; }
        .mobile-view #utility-buttons { 
            position: fixed;
            bottom: 20px;
            left: 105px; /* S1.2: Moved from right to left */
            transform: translateX(-50%); /* S1.2: Adjusted for left alignment */
            display: flex;
            flex-direction: row;
            gap: 12px; 
            z-index: 10; 
        }
        .utility-label { font-size: 12px; color: white; text-shadow: 1px 1px 1px black; margin-top: 2px; }

        .mobile-controls { display: none; }
        .mobile-view .mobile-controls { display: block; }
        #move-stick-area, #aim-stick-area { position: fixed; bottom: 80px; width: 150px; height: 150px; background: rgba(0, 0, 0, 0.2); border-radius: 50%; user-select: none; }
        #move-stick-area { left: 30px; }
        #aim-stick-area { right: 30px; }
        #move-stick-thumb, #aim-stick-thumb { position: absolute; width: 60px; height: 60px; background: rgba(255, 255, 255, 0.3); border-radius: 50%; top: 45px; left: 45px; pointer-events: none; transition: transform 0.05s; }
        #shoot-btn { position: fixed; bottom: 240px; right: 65px; width: 80px; height: 80px; border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 50%; user-select: none; background: rgba(185, 28, 28, 0.5); }
        #reload-btn { position: fixed; bottom: 240px; left: 65px; width: 80px; height: 80px; border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 50%; user-select: none; background: rgba(23, 37, 84, 0.5); display: none; }
        
        /* S1.2: Nitro button redesign for mobile */
        #boost-btn { 
            position: fixed; 
            bottom: 20px; 
            right: 105px; /* Centered under right joystick */
            transform: translateX(50%);
            width: 150px; /* Width of joystick */
            height: 50px; /* Bar shape */
            border: 2px solid rgba(255, 255, 255, 0.4); 
            border-radius: 10px; /* Rounded corners for bar */
            user-select: none; 
            background: rgba(250, 204, 21, 0.5); 
            /* display: none; // Managed by JS */
            display: none; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            font-weight: 700; 
            text-shadow: 1px 1px 2px black;
        }

        #shoot-indicator-wrapper { position: absolute; top: -15px; left: 50%; transform: translateX(-50%); display: flex; gap: 4px; }
        #shoot-indicator-yellow, #shoot-indicator-green { width: 10px; height: 10px; border-radius: 50%; background-color: #1a202c; }
        #shoot-btn.active { background-color: rgba(185, 28, 28, 0.8) !important; border-color: white !important; }
        #reload-btn.active { background-color: rgba(30, 58, 138, 0.8) !important; border-color: white !important; }
        #boost-btn.active { background-color: rgba(250, 204, 21, 0.8) !important; border-color: white !important; }
        
        .shake { animation: shake 0.2s; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } }
        .money-pulse { transform: scale(1.1); color: #86efac !important; }
        .health-pulse { animation: health-pulse 1s infinite; }
        @keyframes health-pulse { 50% { transform: scale(1.1); color: #f87171; } }

        /* Admin Panel Compact Styles */
        .admin-button { padding: 8px 12px !important; font-size: 14px !important; width: 100%; }
        .admin-button-large { padding: 16px 12px !important; font-size: 16px !important; line-height: 1.2; }

        /* Achievements UI Styles */
        #achievements-list { list-style: none; padding: 0; width: 100%; max-width: 500px; display: flex; flex-direction: column; gap: 0.5rem; }
        .achievement-item { background: rgba(0,0,0,0.2); padding: 0.75rem; border-radius: 0.5rem; text-align: left; }
        .achievement-item h3 { font-weight: bold; font-size: 1.1rem; margin-bottom: 0.25rem; }
        .achievement-item.locked { background: rgba(0,0,0,0.4); color: #A0AEC0; }
        .achievement-item.locked h3 { color: #718096; }

        /* --- GARAGE UI --- */
        #garage-modal { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white;
            border: 6px solid #A0AEC0;
        }
        .mobile-view #garage-modal {
            border: none;
        }
        #item-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
            align-content: start;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #2d3748; }
        ::-webkit-scrollbar-thumb { background: #4a5568; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #718096; }
        .btn { transition: all 0.2s ease-in-out; border-width: 2px; }
        .btn:hover:not(:disabled) { transform: translateY(-2px); filter: brightness(1.1); }
        .btn:active:not(:disabled) { transform: translateY(0); }
        .btn:disabled { background-color: #4a5568 !important; border-color: #2d3748 !important; color: #a0aec0 !important; cursor: not-allowed !important; }
        
        .category-btn.active { background-color: #4a5568; color: #f7fafc; }
        
        .item-card { border-color: #4a5568; position: relative; }
        .item-card-tag { position: absolute; top: 0.5rem; right: 0.5rem; z-index: 1; }
        .item-card.selected { background-color: #4a5568; border-color: #4299e1; }
        .tank-part { fill: #a0aec0; stroke: #e2e8f0; stroke-width: 1.5; transition: all 0.3s ease-in-out; }
        .tank-part.highlighted { fill: #f6e05e; stroke: #faf089; filter: drop-shadow(0 0 10px #f6e05e); }
        
        .stat-row { display: flex; align-items: center; background-color: rgba(74, 85, 104, 0.5); padding: 0.5rem; border-radius: 0.375rem; }
        .stat-label { color: #a0aec0; width: 8rem; flex-shrink: 0; }
        .stat-value { font-weight: 600; width: 4rem; flex-shrink: 0; }
        .stat-bar-bg { background-color: black; border-radius: 9999px; height: 8px; width: 100%; overflow: hidden; }
        .stat-bar-fill { background-color: #22c55e; height: 100%; border-radius: 9999px; transition: width 0.3s ease-in-out; }
        .upgrade-btn-content { display: flex; flex-direction: column; align-items: center; justify-content: center; line-height: 1.2; }
        .upgrade-btn-effect { font-size: 0.75rem; opacity: 0.8; }

        @media (max-width: 767px) {
            .mobile-slim .category-btn.active { border-bottom-color: #4299e1; }
            .mobile-slim #item-list {
                grid-template-columns: repeat(2, 1fr);
                gap: 0.5rem;
            }
            .mobile-slim .p-4 { padding: 0.5rem; }
            .mobile-slim .p-6 { padding: 0.75rem; }
            .mobile-slim .text-2xl { font-size: 1.25rem; }
            .mobile-slim .text-lg { font-size: 0.9rem; }
            .mobile-slim .font-semibold { font-weight: 500; }
            .mobile-slim .py-2 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
            .mobile-slim .px-3 { padding-left: 0.5rem; padding-right: 0.5rem; }
            .mobile-slim .item-card { padding: 0.5rem; }
            .mobile-slim .item-card h3 { font-size: 0.8rem; }
            .mobile-slim .item-card p { font-size: 0.7rem; }
            .mobile-slim #item-details { padding-top: 0.75rem; margin-top: 0.75rem; }
            .mobile-slim #item-details h2 { font-size: 1.1rem; margin-bottom: 0.25rem; }
            .mobile-slim #item-details p { font-size: 0.8rem; margin-bottom: 0.5rem; }
            .mobile-slim .stat-row { padding: 0.25rem; }
            .mobile-slim .stat-label { font-size: 0.75rem; width: 5rem; }
            .mobile-slim .stat-value { font-size: 0.75rem; width: 3rem; }
            .mobile-slim .btn { font-size: 0.8rem; padding: 0.5rem 0.75rem; }
            .mobile-slim .upgrade-btn-effect { font-size: 0.65rem; }
            .mobile-slim .mobile-header-tank { height: 1.25rem; width: auto; }
        }
        @media (min-width: 768px) {
            .category-btn.active { border-left-color: #4299e1; }
        }

        #saving-overlay { z-index: 101; }
        #autosave-notification { 
            position: fixed; 
            top: 10px; 
            left: 50%;
            transform: translateX(calc(-100% - 80px)); /* Position left of the centered version # */
            background: rgba(0,0,0,0.8); 
            color: white; 
            padding: 5px 10px; 
            border-radius: 6px; 
            z-index: 210; 
            opacity: 0; 
            transition: opacity 0.5s ease-in-out; 
            pointer-events: none; 
            font-size: 12px;
        }
        #on-screen-console {
            position: fixed;
            bottom: 50px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: #00FF00;
            font-family: monospace;
            padding: 8px;
            border-radius: 5px;
            z-index: 300;
            display: none;
            font-size: 14px;
            min-width: 150px;
        }
        .console-toggle-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 12px 24px;
            font-size: 18px;
            user-select: none;
            width: 100%;
            justify-content: center;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="start-screen">
        <div id="version-display"></div>
        <img id="splash-image" src="https://i.imgur.com/CAPoMJE.jpeg" alt="Tank Tycoon Splash Screen" onerror="this.onerror=null;this.src='https://placehold.co/600x400/2D3748/FFFFFF?text=Tank+Tycoon';">
        <div class="loader" style="display: none;"></div>
        <div id="loading-text">Loading...</div>
        <!-- X1.2: This container will be dynamically filled by JavaScript -->
        <div id="start-button-container" class="start-button-container"></div>
    </div>

    <div id="game-wrapper" class="game-wrapper">
        <div id="game-version-display"></div>
        <div id="pause-btn">❚❚</div>
        <div class="desktop-header">
            <div class="header-left">
            </div>
            <div class="header-right">
                <div id="money-display">$0</div>
                <div id="health-display">5/5 HP</div>
                <div id="ammo-display">32/32</div>
                <div id="blueprint-display"></div>
            </div>
        </div>

        <div id="game-container" class="relative">
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>

    <div id="utility-buttons"></div>
    <div id="mobile-ui-container" class="ui-container"></div>
    <div id="achievement-notification"></div>
    <div id="debug-panel"></div>
    <div id="ping-spy-panel"></div>
    <div id="on-screen-console"></div>
    <div id="transition-overlay"></div>
    <div id="saving-overlay" class="modal"><div class="modal-content"><h2>Saving game...</h2></div></div>
    <div id="autosave-notification"></div>

    <!-- Modals -->
    <div id="info-modal" class="modal"><div class="modal-content"><h2 id="info-modal-title" class="text-3xl"></h2><p id="info-modal-text"></p><button id="info-modal-close" class="modal-button confirm-button">OK</button></div></div>
    <div id="death-modal" class="modal"><div class="modal-content"><h2 class="text-3xl mb-4">YOU DIED</h2><button id="respawn-btn" class="modal-button">RESPAWN</button></div></div>
    <div id="pause-modal" class="modal"><div class="modal-content"><h2 id="pause-modal-title" class="text-3xl">PAUSED</h2><p id="autosave-confirm-text" style="color:white; font-size: 0.9rem; height: 1.2rem;"></p><button id="resume-btn" class="modal-button confirm-button">RESUME</button><button id="admin-menu-btn" class="modal-button admin-button-color">ADMIN TOOLS</button><button id="achievements-btn" class="modal-button info-button">🏆 ACHIEVEMENTS</button><button id="pause-options-btn" class="modal-button info-button">OPTIONS</button><button id="main-menu-btn" class="modal-button">MAIN MENU</button></div></div>
    <div id="achievements-modal" class="modal"><div class="modal-content"><h2 id="achievements-title" class="text-3xl">ACHIEVEMENTS</h2><ul id="achievements-list"></ul><button id="achievements-back-btn" class="modal-button confirm-button">BACK</button></div></div>
    <div id="save-load-modal" class="modal"><div class="modal-content"><h2 class="text-3xl">SELECT SLOT</h2><div id="save-slots-container" class="w-full flex flex-col gap-4"></div></div></div>
    <div id="start-over-confirm-modal" class="modal"><div class="modal-content"><h2 class="text-3xl">DELETE WORLD?</h2><p>A new game will override your previous progress in this slot.</p><div class="flex gap-4"><button id="start-over-confirm-yes" class="modal-button">YES</button><button id="start-over-confirm-no" class="modal-button confirm-button">NO</button></div></div></div>
    <div id="restart-confirm-modal" class="modal"><div class="modal-content"><h2 class="text-3xl">RESTART GAME?</h2><p>All progress will be lost.</p><div class="flex gap-4"><button id="restart-confirm-yes" class="modal-button">YES</button><button id="restart-confirm-no" class="modal-button confirm-button">NO</button></div></div></div>
    <div id="pc-controls-modal" class="modal"><div class="modal-content"><h2 class="text-3xl">PC CONTROLS</h2><div id="pc-controls-list" class="text-left text-lg"></div><button id="pc-controls-back-btn" class="modal-button confirm-button">BACK</button></div></div>
    <div id="options-modal" class="modal"><div class="modal-content"><h2 class="text-3xl">OPTIONS</h2><button id="options-achievements-btn" class="modal-button info-button">🏆 ACHIEVEMENTS</button><button id="options-controls-btn" class="modal-button info-button">CONTROLS</button><div id="options-audio-toggle" class="audio-toggle info-button"><span class="audio-toggle-label">AUDIO:</span><span id="audio-toggle-on" class="audio-toggle-option">ON</span><span id="audio-toggle-off" class="audio-toggle-option">OFF</span></div><label class="console-toggle-container info-button"><input type="checkbox" id="toggle-console-checkbox">Show Console Log</label><button id="options-delete-world-btn" class="modal-button" style="margin-top: 2rem;">DELETE WORLD</button><button id="options-back-btn" class="modal-button confirm-button">BACK</button></div></div>
    
    <div id="garage-modal" class="modal">
        <div id="garage-ui-content" class="w-11/12 max-w-4xl h-5/6 max-h-[700px] bg-gray-800 rounded-2xl shadow-2xl flex flex-col md:flex-row overflow-hidden">
            <div class="md:hidden p-4 border-b-2 border-gray-700 flex items-center justify-between">
                <div class="flex-1 flex items-center gap-4">
                    <h1 class="text-2xl font-black tracking-wider">GARAGE</h1>
                    <svg id="mobile-tank-diagram" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 120" class="mobile-header-tank">
                        <g id="mobile-svg-drivetrain" class="tank-part" transform="translate(0, 10)"><path d="M10 95 C 5 95, 5 85, 10 85 L 190 85 C 195 85, 195 95, 190 95 Z M 30 90 A 5 5 0 1 1 20 90 A 5 5 0 0 1 30 90 Z M 60 90 A 5 5 0 1 1 50 90 A 5 5 0 0 1 60 90 Z M 90 90 A 5 5 0 1 1 80 90 A 5 5 0 0 1 90 90 Z M 120 90 A 5 5 0 1 1 110 90 A 5 5 0 0 1 120 90 Z M 150 90 A 5 5 0 1 1 140 90 A 5 5 0 0 1 150 90 Z M 180 90 A 5 5 0 1 1 170 90 A 5 5 0 0 1 180 90 Z"/></g>
                        <g id="mobile-svg-chassis" class="tank-part"><path d="M25 84 L 40 55 H 160 L 175 84 H 25 Z" /></g>
                        <g id="mobile-svg-turret" class="tank-part" transform="translate(0, -15)"><path d="M65 53 L 75 30 H 125 L 135 53 H 65 Z M 125 40 H 180 V 45 H 125 Z" /></g>
                    </svg>
                </div>
                <button id="mobile-garage-exit-btn" class="btn bg-red-600 border-red-800 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-lg shadow-lg">EXIT</button>
            </div>
            
            <div class="w-full md:w-1/3 bg-gray-900/50 p-4 md:p-6 md:border-r-2 border-gray-700 flex flex-col">
                <h1 class="hidden md:block text-4xl font-black text-center mb-8 tracking-wider">GARAGE</h1>
                
                <nav id="category-nav" class="flex flex-row md:flex-col md:space-y-3 justify-center"></nav>
                
                <div id="tank-diagram-container" class="my-auto hidden md:flex justify-center items-center p-4">
                    <svg id="desktop-tank-diagram" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 120" class="max-w-full h-auto">
                        <g id="desktop-svg-drivetrain" class="tank-part" transform="translate(0, 10)"><path d="M10 95 C 5 95, 5 85, 10 85 L 190 85 C 195 85, 195 95, 190 95 Z M 30 90 A 5 5 0 1 1 20 90 A 5 5 0 0 1 30 90 Z M 60 90 A 5 5 0 1 1 50 90 A 5 5 0 0 1 60 90 Z M 90 90 A 5 5 0 1 1 80 90 A 5 5 0 0 1 90 90 Z M 120 90 A 5 5 0 1 1 110 90 A 5 5 0 0 1 120 90 Z M 150 90 A 5 5 0 1 1 140 90 A 5 5 0 0 1 150 90 Z M 180 90 A 5 5 0 1 1 170 90 A 5 5 0 0 1 180 90 Z"/></g>
                        <g id="desktop-svg-chassis" class="tank-part"><path d="M25 84 L 40 55 H 160 L 175 84 H 25 Z" /></g>
                        <g id="desktop-svg-turret" class="tank-part" transform="translate(0, -15)"><path d="M65 53 L 75 30 H 125 L 135 53 H 65 Z M 125 40 H 180 V 45 H 125 Z" /></g>
                    </svg>
                </div>
                <button id="garage-exit-btn" class="btn mt-auto bg-red-600 border-red-800 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg shadow-lg hidden md:block">EXIT</button>
            </div>
            
            <div class="w-full md:w-2/3 p-4 md:p-6 flex flex-col flex-grow md:overflow-hidden overflow-y-auto">
                <div id="item-list" class="flex-grow-0"></div>
                <div id="item-details" class="mt-4 md:mt-6 pt-4 md:pt-6 border-t-2 border-gray-700 flex-shrink-0">
                    <div class="text-center text-gray-500"><p class="text-lg">Select an item to see details</p></div>
                </div>
            </div>
        </div>
    </div>


    <div id="admin-tools-modal" class="modal">
        <div class="modal-content" style="max-width: 320px; flex-direction: column; gap: 1rem;">
            <h2 class="text-3xl">ADMIN TOOLS</h2>
            
            <div class="w-full flex flex-col gap-2 mb-2">
                <button id="admin-max-base" class="modal-button admin-button-color admin-button-large">Max out:<br>base, $, HP</button>
            </div>

			<div class="w-full flex flex-col gap-2 mb-2">
                <button id="admin-give-mg-bp" class="modal-button admin-button-color admin-button">+MG BP</button>
                <button id="admin-give-nb-bp" class="modal-button admin-button-color admin-button">+NB BP</button>
                <button id="admin-spawn-jugg" class="modal-button admin-button-color admin-button">+JUGG</button>
                <button id="admin-spawn-set" class="modal-button admin-button-color admin-button">+SET</button>
            </div>

            <div class="w-full flex flex-col gap-2">
                <button id="admin-respawn" class="modal-button admin-button">Respawn</button>
                <button id="admin-hp-1" class="modal-button admin-button">HP=1</button>
                <button id="admin-money-0" class="modal-button admin-button">$=0</button>
            </div>

            <button id="admin-tools-exit" class="modal-button confirm-button mt-2">EXIT</button>
        </div>
    </div>

    <div class="mobile-controls">
        <div id="move-stick-area"><div id="move-stick-thumb"></div></div>
        <div id="aim-stick-area"><div id="aim-stick-thumb"></div></div>
        <div id="shoot-btn"><div id="shoot-indicator-wrapper"><div id="shoot-indicator-yellow"></div><div id="shoot-indicator-green"></div></div></div>
        <div id="reload-btn">R</div>
        <div id="boost-btn">NITRO BOOST</div> <!-- S1.2: Changed text -->
    </div>

<script>
// --- SETUP & STATE ---
const GAME_VERSION = "Pre-Alpha 4.6";
const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');
const world = { width: 4000, height: 4000, gridSize: 40, chunkSize: 16 * 40 };
let camera = { x: 0, y: 0, width: 0, height: 0, targetX: 0, targetY: 0, shake: 0, zoom: 1.0 };
let player, keys, touchState, sfx, playerStats, achievements;
let worldState = { worldObjects: [], bullets: [], enemies: [], deadEnemies: [], pickups: [], terrain: [], base: {}, visitedChunks: new Set(), particles: [], decorations: [], baseDecorations: [], activeBursts: [], pings: [], deathBags: [], tileMap: [], activeFollowerCount: 0 };
let animationFrameId, lastTime, isPaused = false, isAudioInitialized = false, isMuted = false;
// 2.7 Performance: Sound Throttling
const SOUND_COOLDOWN_MS = 50;
let lastSoundPlayTimes = {};
// Y1.6: Centralized function to update audio toggle UI
function updateAudioToggleUI() {
    const onBtn = document.getElementById('audio-toggle-on');
    const offBtn = document.getElementById('audio-toggle-off');
    if (isMuted) {
        onBtn.classList.remove('active');
        offBtn.classList.add('active');
    } else {
        onBtn.classList.add('active');
        offBtn.classList.remove('active');
    }
}
const openModal = (id) => {
    const modal = document.getElementById(id);
    if (!modal) return;
    if (modalStack.includes(id)) return; // Prevent opening the same modal twice

    if (modalStack.length > 0) {
        const currentTopModal = document.getElementById(modalStack[modalStack.length - 1]);
        if (currentTopModal) currentTopModal.style.display = 'none';
    }
    
    modalStack.push(id);
    modal.style.display = 'flex';
    modal.style.zIndex = 211 + modalStack.length;
};
// The old closeModal is now replaced by handleBackAction
let isPlayerInGarage = false;
let lastPickupSoundTime = 0;
let isDebugVisible = false;
let isConsoleVisible = false;
let isVersionVisible = true;
let isPingSpyVisible = false; let isLoading = false;
let isGameBlocked = false; let justDiedWithLoot = false;
let pingSpyLog = [];
let currentWorldId = 0; // 0: Overworld, 1: Wasteland
let isTransitioning = false;
let modalStack = [];
let isRespawning = false;
let notificationQueue = [];
let lastPingTime = 0;
let deviceMode = 'desktop'; // 'desktop' or 'mobile'
// W1.4 Save System State
let currentSaveSlot = -1;
let lastAutosaveTime = 0;
let masterSeed = null;
const SAVE_KEY = 'tankTycoonSaves_W1.4';

// R2.0: Garage UI State
let garageSelectedCategory = 'Turret';
let garageSelectedItemId = 'standardCannon';

// 2.4 Performance: Spatial Grid for collision optimization
let spatialGrid;
const GRID_CELL_SIZE = 200;

// R2.0: Garage Data
const GLOBAL_MAX_STATS = { Damage: 1, 'Fire Rate': 8 };
const MAX_STATS = { cannon: { Damage: 1, 'Fire Rate': 3, 'Bullet Speed': 150 }, machineGun: { Damage: 0.3, 'Fire Rate': 8, Magazine: 32 }, engine: { Speed: 230 }, armor: { 'Block Chance': 1.0 }, nitro: { 'Boost Power': 3, 'Duration': 1, 'Cooldown': 5 } };
const garageStandardCannonUpgrades = [ { title: "Standard Cannon (Mk. I)", cost: 0, description: "A reliable, all-purpose starting cannon.", stats: { 'Damage': 1, 'Fire Rate': 1, 'Bullet Speed': 100 }, nextUpgradeEffect: "+25% Bullet Speed" }, { title: "Enhanced Cannon (Mk. II)", cost: 500, description: "A reliable, all-purpose faster momentum cannon.", stats: { 'Damage': 1, 'Fire Rate': 1, 'Bullet Speed': 125 }, nextUpgradeEffect: "Unlocks Burst Fire (2 shots)" }, { title: "Enhanced Burst Cannon (Mk. III)", cost: 2500, description: "A burst-fire, high momentum firing cannon.", stats: { 'Damage': 1, 'Fire Rate': 2, 'Bullet Speed': 125 }, nextUpgradeEffect: "+25% Bullet Speed (total +50%)" }, { title: "Premium Burst-Fire Cannon (Mk. IV)", cost: 15000, description: "A burst-fire, very high bullet speed cannon.", stats: { 'Damage': 1, 'Fire Rate': 2, 'Bullet Speed': 150 }, nextUpgradeEffect: "Unlocks Burst Fire (3 shots)" }, { title: "Triple Burst-Fire Cannon (Mk. V)", cost: 75000, description: "A triple burst firing cannon with high bullet momentum.", stats: { 'Damage': 1, 'Fire Rate': 3, 'Bullet Speed': 150 }, nextUpgradeEffect: "MAX TIER" } ];
const garageEngineUpgrades = [ { title: "Standard Engine (Mk. I)", cost: 0, description: "Default engine block.", stats: { 'Speed': 100 }, nextUpgradeEffect: "+10% Speed" }, { title: "Tuned Engine (Mk. II)", cost: 400, description: "Slightly improved performance.", stats: { 'Speed': 110 }, nextUpgradeEffect: "+10% Speed (total +20%)" }, { title: "Performance Engine (Mk. III)", cost: 2000, description: "Noticeably faster.", stats: { 'Speed': 120 }, nextUpgradeEffect: "+10% Speed (total +30%)" }, { title: "Racing Engine (Mk. IV)", cost: 12000, description: "Professional-grade speed.", stats: { 'Speed': 130 }, nextUpgradeEffect: "+20% Speed (total +50%)" }, { title: "Experimental Engine (Mk. V)", cost: 60000, description: "Maximum legal speed.", stats: { 'Speed': 150 }, nextUpgradeEffect: "+20% Speed (total +70%)" }, { title: "Overclocked Engine (Mk. VI)", cost: 300000, description: "Pushing the engine beyond its recommended limits for a significant speed advantage.", stats: { 'Speed': 170 }, nextUpgradeEffect: "+25% Speed (total +95%)" }, { title: "Singularity Engine (Mk. VII)", cost: 1500000, description: "A marvel of engineering, powered by a contained micro-singularity.", stats: { 'Speed': 195 }, nextUpgradeEffect: "+35% Speed (total +130%)" }, { title: "Hyperdrive Engine (Mk. VIII)", cost: 7500000, description: "The absolute pinnacle of propulsion technology, bordering on theoretical physics.", stats: { 'Speed': 230 }, nextUpgradeEffect: "MAX TIER" } ];
const garageArmorUpgrades = [ { title: "Reinforced Plating (Tier 1)", cost: 10000, description: "Adds a basic layer of protection.", stats: { 'Block Chance': 0.05 }, nextUpgradeEffect: "+5% Block Chance" }, { title: "Composite Armor (Tier 2)", cost: 50000, description: "Advanced materials provide better damage mitigation.", stats: { 'Block Chance': 0.10 }, nextUpgradeEffect: "+10% Block Chance" }, { title: "Reactive Armor (Tier 3)", cost: 250000, description: "Explosive plates offer superior defense.", stats: { 'Block Chance': 0.20 }, nextUpgradeEffect: "MAX TIER" } ];
const garageBlueprintData = { machineGun: { id: 'machineGun', title: "Machine Gun", cost: 20000, description: "Shreds light armor with a high rate of fire.", stats: MAX_STATS.machineGun }, nitroBoost: { id: 'nitroBoost', title: "Nitro Boost", cost: 100000, description: "Provides a 300% speed boost for 1 second, with a 5 second cooldown." } };
const garageData = { 'Turret': [ { id: 'standardCannon', name: 'Standard Cannon', type: 'upgrade', upgrades: garageStandardCannonUpgrades, maxStats: MAX_STATS.cannon }, { id: 'machineGun', name: 'Machine Gun', type: 'blueprint', blueprint: garageBlueprintData.machineGun, maxStats: MAX_STATS.machineGun } ], 'Chassis': [ { id: 'armor', name: 'Armor Plating', type: 'upgrade', upgrades: garageArmorUpgrades, maxStats: MAX_STATS.armor } ], 'Drivetrain': [ { id: 'engine', name: 'Engine', type: 'upgrade', upgrades: garageEngineUpgrades, maxStats: MAX_STATS.engine }, { id: 'nitroBoost', name: 'Attachment: Nitro Boost', type: 'blueprint', blueprint: garageBlueprintData.nitroBoost } ] };

// --- ECONOMY & BLUEPRINT DATA ---
const cashBayUpgrades = [
    { cost: 25, passive: 0.10, active: 0.20 }, { cost: 100, passive: 0.20, active: 0.50 },
    { cost: 500, passive: 1, active: 2.5 }, { cost: 2500, passive: 5, active: 10 },
    { cost: 5000, passive: 10, active: 25 }, { cost: 25000, passive: 100, active: 250 },
    { cost: 100000, passive: 500, active: 1000 }, { cost: 500000, passive: 2500, active: 5000 },
    { cost: 5000000, passive: 5000, active: 10000 }, { cost: 25000000, passive: 25000, active: 50000 }
];
const medBayUpgrades = [ 
    { cost: 0, heal: 0, maxHp: 0 }, { cost: 25, heal: 0.25, maxHp: 5 }, 
    { cost: 100, heal: 0.5, maxHp: 5 }, { cost: 500, heal: 0.75, maxHp: 5 }, 
    { cost: 1000, heal: 1, maxHp: 10 }, { cost: 5000, heal: 3, maxHp: 10 }, 
    { cost: 25000, heal: 3, maxHp: 15 }, { cost: 100000, heal: 4, maxHp: 20 }, 
    { cost: 500000, heal: 5, maxHp: 30 }, { cost: 2500000, heal: 7, maxHp: 40 }, 
    { cost: 10000000, heal: 10, maxHp: 50 }
];
const GARAGE_UNLOCK_COST = 250;

// --- DYNAMIC ENGINE SOUND SYSTEM ---
let enginePlayer; let engineFadeNode;
const engineAudioUrl = 'https://dl.dropboxusercontent.com/scl/fi/3vkvoeltskmfuhnuoly2m/engine_trimmed_loopable.mp3?rlkey=d844chyrjkriy4ph61cyitn04&st=ehu6kt81';
const FADE_TIME = 0.4; const MASTER_VOLUME = 10.8; const PITCH_START = 0.5; const PITCH_END = 1.0;
async function initEngineSound() {
    if (enginePlayer) return;
    try {
        engineFadeNode = new Tone.Gain(0).toDestination();
        enginePlayer = new Tone.Player({
            url: engineAudioUrl,
            loop: true,
            playbackRate: PITCH_START,
            volume: MASTER_VOLUME,
            onload: () => {
                console.log("Engine audio file loaded, starting playback.");
                enginePlayer.start();
            },
        }).connect(engineFadeNode);
    } catch (error) {
        console.error("Error initializing engine sound with Tone.js:", error);
    }
}
function updateEngineSound(deltaTime) {
    if (!enginePlayer || !engineFadeNode || !player) return;
    const isTryingToMove = (touchState.moveStick.x !== 0 || touchState.moveStick.y !== 0) || keys.w || keys.a || keys.s || keys.d;
    const targetVolume = isTryingToMove ? 1.0 : 0.0;
    const speedRatio = Math.min(1, Math.abs(player.currentSpeed) / 2.64);
    let targetPitch = PITCH_START + (PITCH_END - PITCH_START) * speedRatio;
    if (isTryingToMove && speedRatio < 0.1) { targetPitch = PITCH_START; }
    targetPitch *= player.pitchPenalty;

    engineFadeNode.gain.rampTo(targetVolume, FADE_TIME);
    enginePlayer.playbackRate = targetPitch;

    if (player.pitchPenalty < 1) {
        player.pitchPenalty = Math.min(1, player.pitchPenalty + (deltaTime / 300));
    }
}

// --- INITIALIZATION & STATE MANAGEMENT ---
function initAchievements() {
    achievements = {
        spin: { id: 'spin', name: "You Spin Me Right Round", description: "Rotate your turret for more than 10 consecutive seconds.", unlocked: false },
        billionaire: { id: 'billionaire', name: "This mechanic shouldn't exist IRL", description: "Become a billionaire.", unlocked: false },
        fiveDollars: { id: 'fiveDollars', name: "And then I found five dollars", description: "Pickup exactly $5 off the ground.", unlocked: false },
        respawn: { id: 'respawn', name: "Visiting Pam Bondi's Desk", description: "Disappear then somehow magically reappear (respawn once).", unlocked: false },
        dieHard: { id: 'dieHard', name: "Not the best", description: "Die 5 times in the same 5 minutes.", unlocked: false },
        doubleKill: { id: 'doubleKill', name: "Double Kill", description: "Eliminate two enemies less than 3 seconds apart.", unlocked: false },
        tripleKill: { id: 'tripleKill', name: "Triple Kill", description: "Eliminate three enemies less than 3 seconds apart.", unlocked: false },
        kilimanjaro: { id: 'kilimanjaro', name: "Kilimanjaro", description: "Eliminate 7 enemies in 10 seconds.", unlocked: false },
    };
}
function initPlayerState(fullReset = false) {
    const prevState = player;
    player = {
        x: worldState.base.center?.x ?? 150, y: worldState.base.center?.y ?? 100, width: 35, height: 35, bodyAngle: 0, turretAngle: 0,
        hp: 5, maxHp: 5, moneyFloat: 0,
        isHit: false, hitTime: 0, isDead: false, timeSpentMoving: 0,
        aimLine: { active: false, lastActiveTime: 0, opacity: 1.0 }, isInWater: false, lastSplashTime: 0, lastSplashParticleTime: 0,
        last1HpSoundTime: 0, last2HpSoundTime: 0,
        turretSpinDirection: 0, consistentSpinTimer: 0, lastTurretAngle: 0, totalRotation: 0,
        lastUpgradedPadId: null, lastMouseMoveTime: 0, lastSplashSoundTime: 0,
        prevDx: 0, prevDy: 0, pitchPenalty: 1, lastHealParticleTime: 0, lastHealTickTime: 0,
        speed: 1.94, currentSpeed: 0,
        acceleration: 0.025,
        cannonTier: 1, engineTier: 1, armorTier: 0, blockChance: 0,
        deathTimestamps: [], killTimestamps: [],
        canEnterGarage: true, isOnCashBay: false, lastMoneyParticleTime: 0,
        blockEffect: { active: false, time: 0, radius: 0 },
        equipment: { turret: 'standardCannon', attachment: null }, lastShotTime: 0,
        fireRate: 1000, bulletSpeed: 6, bulletDamage: 1, burstCount: 1,
        mg: { currentAmmo: 32, magSize: 32, reloadTime: 1500, isReloading: false, lastReloadTime: 0 },
        blueprints: {},
        installedBlueprints: {},
        fabricated: {},
        carryingBlueprints: [],
        boost: { charge: 100, maxCharge: 100, isBoosting: false, cooldown: 5000, lastUsed: 0 }
    };

    if (!fullReset && prevState) {
        player.moneyFloat = prevState.moneyFloat;
        player.cannonTier = prevState.cannonTier;
        player.engineTier = prevState.engineTier;
        player.armorTier = prevState.armorTier;
        player.blueprints = { ...prevState.blueprints };
        player.fabricated = { ...prevState.fabricated };
        player.equipment = { ...prevState.equipment };
        player.installedBlueprints = { ...prevState.installedBlueprints };
    }

    keys = { w: false, a: false, s: false, d: false, ' ': false, r: false, shift: false, arrowup: false, arrowdown: false, arrowleft: false, arrowright: false, escape: false, q: false };
    touchState = { moveTouchId: null, aimTouchId: null, fireTouchId: null, reloadTouchId: null, boostTouchId: null, moveStick: { x: 0, y: 0 }, aimStick: { x: 0, y: 0 } };
    worldState.bullets = []; worldState.activeBursts = [];
    
    if (worldState.base && worldState.base.medBay) { 
        const medBayData = medBayUpgrades[worldState.base.medBay.tier]; 
        player.maxHp = medBayData.maxHp > 0 ? medBayData.maxHp : 5; 
        player.hp = player.maxHp; 
    }
    updateWeaponStats();
    updatePlayerStatsFromUpgrades();
}
function initWorldState() { 
    playerStats = { kills: 0, moneyEarned: 0, treesBroken: 0, unlockedAchievements: [], hasRespawnedOnce: false, hasDroppedMoneyOnce: false, hasSeenDeathTip: false }; 
    worldState.visitedChunks.clear(); 
    generateWorld(currentWorldId); 
    if (player) {
        player.x = worldState.base.center.x - player.width / 2;
        player.y = worldState.base.center.y - player.height / 2;
    }
}
function resizeCanvas() {
    const isMobile = deviceMode === 'mobile';
    const wrapper = document.getElementById('game-wrapper');
    const header = document.querySelector('.desktop-header');
    const gameContainer = document.getElementById('game-container');

    let newWidth, newHeight;

    if (isMobile) {
        newWidth = wrapper.clientWidth;
        newHeight = wrapper.clientHeight; // S1.2: Expand canvas to full height
        gameContainer.style.marginTop = '0px'; // S1.2: Remove margin
        gameContainer.style.height = `${wrapper.clientHeight}px`;
        canvas.style.height = `${wrapper.clientHeight}px`; // S1.2: Use full height
        canvas.style.width = `${newWidth}px`;
    } else {
        newWidth = wrapper.clientWidth;
        newHeight = wrapper.clientHeight;
        gameContainer.style.marginTop = '0px';
        gameContainer.style.width = `${newWidth}px`;
        gameContainer.style.height = `${newHeight}px`;
        canvas.style.width = `${newWidth}px`;
        canvas.style.height = `${newHeight}px`;
    }
    
    const scale = Math.min(window.devicePixelRatio || 1, 1.5);
    canvas.width = newWidth * scale;
    canvas.height = newHeight * scale;
    ctx.scale(scale, scale);

    camera.width = newWidth / camera.zoom;
    camera.height = newHeight / camera.zoom;

    if (!worldState.base.x) initWorldState();
}


// --- AUDIO ---
async function initAudio() {
    if (isAudioInitialized) return;
    try {
        await Tone.start();
        isAudioInitialized = true;
        const ambienceChannel = new Tone.Channel().toDestination();
	sfx = { 
            reload: new Tone.Player("https://raw.githubusercontent.com/Spamfan/Audio-host/main/reload.mp3").toDestination(),
            shoot: new Tone.Player("https://raw.githubusercontent.com/Spamfan/Audio-host/main/Bravo_cannon1.mp3").toDestination(), 
            hit: new Tone.Player("https://raw.githubusercontent.com/Spamfan/Audio-host/main/Impact1.mp3").toDestination(), 
            explode: new Tone.Player("https://raw.githubusercontent.com/Spamfan/Audio-host/main/Impact4.mp3").toDestination(), 
            pickup: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).toDestination(), 
            hurt: new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination(), 
            splash: new Tone.NoiseSynth({ noise: { type: 'brown' }, filter: { type: 'lowpass', frequency: 400 }, envelope: { attack: 0.05, decay: 0.4, sustain: 0 } }).toDestination(), 
            woodBreak: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.15, sustain: 0 } }).toDestination(), 
            rockCrack: new Tone.MembraneSynth({ pitchDecay: 0.1, octaves: 2, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.1 } }).toDestination(), 
            lowHealth: new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.2, decay: 0.5, sustain: 0.1, release: 0.5 } }).toDestination(), 
            block: new Tone.Player("https://raw.githubusercontent.com/Spamfan/Audio-host/main/shield1.mp3").toDestination(),
            ping: new Tone.Player("https://raw.githubusercontent.com/Spamfan/Audio-host/main/radar.mp3").toDestination(),
            overworldAmbience: new Tone.Player("https://raw.githubusercontent.com/Spamfan/Audio-host/main/birds.mp3").connect(ambienceChannel),
            wastelandAmbience: new Tone.Player("https://raw.githubusercontent.com/Spamfan/Audio-host/main/Wind.mp3").connect(ambienceChannel),
            uiClick: new Tone.Player("https://raw.githubusercontent.com/Spamfan/Audio-host/main/UIsoft.mp3").toDestination(),
            success: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 } }).toDestination(),
            // X1.3: Use correct, direct-download link for Nitro
            nitro: new Tone.Player("https://raw.githubusercontent.com/Spamfan/Audio-host/main/Nitro1sec.mp3").toDestination()
        }; 
        sfx.shoot.volume.value = -8; sfx.hit.volume.value = -6; sfx.explode.volume.value = -4; sfx.pickup.volume.value -= 6; sfx.hurt.volume.value -= 6; sfx.splash.volume.value -= 6; sfx.woodBreak.volume.value -= 6; sfx.rockCrack.volume.value -= 6; sfx.lowHealth.volume.value = 0; sfx.block.volume.value = -6; sfx.ping.volume.value = -10; sfx.overworldAmbience.volume.value = -6; sfx.overworldAmbience.loop = true; sfx.wastelandAmbience.volume.value = -4; sfx.wastelandAmbience.loop = true; sfx.uiClick.volume.value = -6; sfx.success.volume.value = -10; sfx.reload.volume.value = -5; 
        sfx.nitro.volume.value = 10; // Set nitro volume
        console.log("SFX Audio initialized. Pre-loading...");
        await Tone.loaded();
        await initEngineSound();
        console.log("Audio pre-loading complete.");
    } catch (e) { console.error("Could not start audio context:", e); } 
}
function playSound(soundName, ...args) { 
    if (!isAudioInitialized || Tone.getDestination().mute) return; 

    // 2.8 Sound Throttling for Synths
    const now = Date.now();
    // 'hurt' is the primary cause of the crash. 'pickup' can also be spammed.
    const throttledSounds = ['hurt', 'pickup'];
    if (throttledSounds.includes(soundName)) {
        const lastPlayed = lastSoundPlayTimes[soundName] || 0;
        if (now - lastPlayed < SOUND_COOLDOWN_MS) {
            return; // Cooldown active, skip playing
        }
        lastSoundPlayTimes[soundName] = now;
    }

    const sound = sfx[soundName];
    if (sound && typeof sound.triggerAttackRelease === 'function') {
        sound.triggerAttackRelease(...args);
    }
}
function playSuccessSound() { if (!isAudioInitialized) return; const now = Tone.now(); sfx.success.triggerAttackRelease("G5", "8n", now); sfx.success.triggerAttackRelease("C6", "8n", now + 0.1); }
function playUrlSound(soundName, ownerType = 'player', playbackRate = 1.0) {
    if (!isAudioInitialized || Tone.getDestination().mute || !sfx[soundName] || !sfx[soundName].loaded) return;

    // 2.7 Sound Throttling Logic
    const now = Date.now();
    const throttledSounds = ['hit', 'block']; // Sounds that can spam and cause crashes
    if (throttledSounds.includes(soundName)) {
        const lastPlayed = lastSoundPlayTimes[soundName] || 0;
        if (now - lastPlayed < SOUND_COOLDOWN_MS) {
            return; // Cooldown active, so we skip playing the sound
        }
        lastSoundPlayTimes[soundName] = now;
    }

    const sound = sfx[soundName];

    let finalRate = playbackRate;
    if (ownerType === 'juggernaut') {
        finalRate *= 1.2;
    } else if (soundName === 'hit' || soundName === 'explode') {
        finalRate *= 0.8;
    }
    
    if (soundName === 'ping') {
        sound.playbackRate = finalRate;
    } else {
        sound.playbackRate = finalRate + (Math.random() - 0.5) * 0.2;
    }
    
    const originalVolume = sound.volume.value;
    if (soundName === 'shoot' && ownerType !== 'player') {
        sound.volume.value = -10;
    }
    
    if (sound.state === 'started') {
        sound.stop();
    }
    sound.start();

    // Reset volume if it was changed
    if (soundName === 'shoot' && ownerType !== 'player') {
        sound.volume.value = originalVolume;
    }
}
function manageAmbience() {
    if (!isAudioInitialized || !sfx.overworldAmbience.loaded || !sfx.wastelandAmbience.loaded) return;
    
    const shouldPlayOverworld = !isPaused && !isPlayerInGarage && currentWorldId === 0;
    const shouldPlayWasteland = !isPaused && !isPlayerInGarage && (currentWorldId === 1 || currentWorldId === 2);

    if (shouldPlayOverworld && sfx.overworldAmbience.state !== 'started') {
        sfx.wastelandAmbience.stop();
        sfx.overworldAmbience.start();
    } else if (shouldPlayWasteland && sfx.wastelandAmbience.state !== 'started') {
        sfx.overworldAmbience.stop();
        sfx.wastelandAmbience.start();
    } else if (!shouldPlayOverworld && !shouldPlayWasteland) {
        if (sfx.overworldAmbience.state === 'started') sfx.overworldAmbience.stop();
        if (sfx.wastelandAmbience.state === 'started') sfx.wastelandAmbience.stop();
    }
}
// --- DRAWING & AESTHETICS ---
function drawStroked(drawFunc) { ctx.lineWidth = 3; ctx.strokeStyle = 'black'; ctx.stroke(); drawFunc(); }
function drawTank(x, y, width, height, bodyAngle, turretAngle, bodyColor = "#A0AEC0", turretColor = "#718096", isHit = false, isBoosting = false, decorations = null) { if (isHit) bodyColor = '#ef4444'; ctx.save(); ctx.translate(x + width / 2, y + height / 2); if(isBoosting) { const boostColor = `rgba(250, 204, 21, ${0.5 + Math.random() * 0.5})`; ctx.fillStyle = boostColor; ctx.beginPath(); ctx.moveTo(-width/2, -height/4); ctx.lineTo(-width, 0); ctx.lineTo(-width/2, height/4); ctx.closePath(); ctx.fill(); } ctx.save(); ctx.rotate(bodyAngle); drawStroked(() => { ctx.fillStyle = "#4A5568"; ctx.fillRect(-width / 2, -height / 2, width, height); ctx.fillStyle = bodyColor; ctx.fillRect(-width / 2 * 0.8, -height / 2 * 0.8, width * 0.8, height * 0.8); }); if (decorations === 'superElite') { ctx.fillStyle = '#facc15'; const diamondSize = 4; const halfW = width / 2, halfH = height / 2; for(let i = 0; i < 3; i++) { const offset = (i - 1) * 8; ctx.fillRect(halfW * 0.8 - diamondSize / 2, offset - diamondSize / 2, diamondSize, diamondSize); ctx.fillRect(-halfW * 0.8 - diamondSize / 2, offset - diamondSize / 2, diamondSize, diamondSize); ctx.fillRect(offset - diamondSize / 2, halfH * 0.8 - diamondSize / 2, diamondSize, diamondSize); ctx.fillRect(offset - diamondSize / 2, -halfH * 0.8 - diamondSize / 2, diamondSize, diamondSize); } } ctx.restore(); ctx.rotate(turretAngle); drawStroked(() => { ctx.fillStyle = turretColor; ctx.fillRect(-width/4, -height/8, width/2, height/4); ctx.fillRect(0, -width/16, width/2, width/8); }); ctx.restore(); }
function drawTree(x, y, size, leafyDetails) {
    const trunkColor = '#6b462a', leavesColor1 = '#166534', trunkSize = size / 5;
    ctx.fillStyle = trunkColor;
    ctx.fillRect(x + size / 2 - trunkSize / 2, y + size / 2, trunkSize, size / 2);
    drawStroked(() => {
        ctx.fillStyle = leavesColor1;
        ctx.beginPath();
        ctx.arc(x + size / 2, y + size / 3, size / 2.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        for(const detail of leafyDetails) {
            ctx.beginPath();
            ctx.arc(x + size / 2 + detail.x, y + size / 3 + detail.y, detail.r, 0, Math.PI * 2);
            ctx.fill();
        }
    });
}
function drawDeadBush(x, y, size) {
    ctx.save();
    ctx.translate(x + size / 2, y + size / 2);
    ctx.strokeStyle = 'black'; // Changed from #5d4037
    ctx.lineWidth = 4;
    ctx.lineCap = 'round';
    for (let i = 0; i < 3; i++) {
        ctx.rotate(Math.PI / 3);
        ctx.beginPath();
        ctx.moveTo(0, -size / 2.5);
        ctx.lineTo(0, size / 2.5);
        ctx.stroke();
    }
    ctx.restore();
}
function drawCrackedBlock(x, y, width, height, color, crackCoords, speckles) {
    ctx.fillStyle = 'black';
    ctx.fillRect(x, y, width, height);
    ctx.fillStyle = color;
    ctx.fillRect(x + 2, y + 2, width - 4, height - 4);

    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    for(const s of speckles) {
        ctx.fillRect(x + s.x, y + s.y, s.size, s.size);
    }
    if (crackCoords) { ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 2; for (const crack of crackCoords) { ctx.beginPath(); ctx.moveTo(x + crack.x1, y + crack.y1); ctx.lineTo(x + crack.x2, y + crack.y2); ctx.stroke(); } }
}
function drawCashBay(x, y, width, height) { ctx.fillStyle = '#166534'; ctx.fillRect(x, y, width, height); ctx.fillStyle = '#22c55e'; ctx.font = 'bold 60px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('$', x + width / 2, y + height / 2); }
function drawCashBag(x, y, size) { ctx.fillStyle = '#166534'; ctx.beginPath(); ctx.roundRect(x, y, size, size, [8]); ctx.fill(); ctx.strokeStyle = 'black'; ctx.lineWidth = 3; ctx.stroke(); ctx.fillStyle = '#fBBF24'; ctx.font = 'bold 24px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('$', x + size / 2, y + size / 2); }
function drawMedBayPad(x, y, width, height) { ctx.fillStyle = '#166534'; ctx.fillRect(x, y, width, height); ctx.fillStyle = '#22c55e'; ctx.font = 'bold 60px Inter'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('+', x + width / 2, y + height / 2); }
function drawGarage(x, y, width, height) { ctx.fillStyle = '#475569'; ctx.fillRect(x, y, width, height); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 4; ctx.strokeRect(x, y, width, height); ctx.fillStyle = '#334155'; ctx.fillRect(x + 5, y + 5, width - 10, height - 10); const doorWidth = width * 0.8; const doorX = x + (width - doorWidth) / 2; ctx.fillStyle = '#1e293b'; ctx.fillRect(doorX, y + 5, doorWidth, height - 10); ctx.strokeStyle = '#475569'; ctx.lineWidth = 2; for(let i = 1; i < 4; i++) { ctx.beginPath(); ctx.moveTo(doorX, y + 5 + i * (height-10)/4); ctx.lineTo(doorX + doorWidth, y + 5 + i * (height-10)/4); ctx.stroke(); } }
function drawBlueprint(x, y, size, id) {
    ctx.font = `${size * 0.8}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    let text = '📄';
    if (id === 'machineGun') text = '📃MG';
    else if (id === 'nitroBoost') text = '📃NB';
    ctx.fillText(text, x + size/2, y + size/2);
}
function drawBlueHeart(x, y, radius) {
    drawStroked(() => {
        ctx.fillStyle = '#3b82f6'; 
        ctx.beginPath();
        ctx.moveTo(x, y - radius / 2);
        ctx.bezierCurveTo(x, y - radius, x - radius, y - radius, x - radius, y);
        ctx.bezierCurveTo(x - radius, y + radius / 2, x, y + radius, x, y + radius);
        ctx.bezierCurveTo(x, y + radius, x + radius, y + radius / 2, x + radius, y);
        ctx.bezierCurveTo(x + radius, y - radius, x, y - radius, x, y - radius / 2);
        ctx.fill();
    });
}

// --- WORLD GENERATION & SPAWNING ---
const TILE_TYPE = { GRASS: 1, DARK_GRASS: 2, SAND: 3, WATER: 4, DARK_WATER: 5, DIRT: 6 };
function generateBase() {
    const baseSize = 14 * world.gridSize;
    const min = world.width * 0.25, max = world.width * 0.75 - baseSize;
    const baseTopLeft = { x: Math.floor((seededRng() * (max - min) + min) / world.gridSize) * world.gridSize, y: Math.floor((seededRng() * (max - min) + min) / world.gridSize) * world.gridSize };
    worldState.base = {
        ...worldState.base,
        x: baseTopLeft.x, y: baseTopLeft.y, size: baseSize,
        center: { x: baseTopLeft.x + baseSize / 2, y: baseTopLeft.y + baseSize / 2 },
        medBay: { tier: worldState.base.medBay?.tier ?? 0, x: baseTopLeft.x + (3 * world.gridSize), y: baseTopLeft.y + (7 * world.gridSize), width: world.gridSize * 2, height: world.gridSize * 2 },
        garage: { tier: worldState.base.garage?.tier ?? 0, x: baseTopLeft.x + (3 * world.gridSize), y: baseTopLeft.y + (3 * world.gridSize), width: world.gridSize * 2, height: world.gridSize * 2 },
        cashBay: { tier: worldState.base.cashBay?.tier ?? 0, x: baseTopLeft.x + (9 * world.gridSize), y: baseTopLeft.y + (7 * world.gridSize), width: world.gridSize * 2, height: world.gridSize * 2 },
        pads: [
            { id: 'medBayPurchase', type: 'medBay', x: baseTopLeft.x + (3.5 * world.gridSize), y: baseTopLeft.y + (10 * world.gridSize) },
            { id: 'garagePurchase', type: 'garage', x: baseTopLeft.x + (3.5 * world.gridSize), y: baseTopLeft.y + (3.5 * world.gridSize) },
            { id: 'cashBayUpgrade', type: 'cashBay', x: baseTopLeft.x + (9.5 * world.gridSize), y: baseTopLeft.y + (10 * world.gridSize) },
        ]
    };
    for (let i = 0; i < 100; i++) { worldState.baseDecorations.push({ x: worldState.base.x + seededRng() * worldState.base.size, y: worldState.base.y + seededRng() * worldState.base.size, angle: seededRng() * Math.PI, length: seededRng() * 10 + 5 }); }
}
function generateWorld(worldId) {
    let worldName;
    if (worldId === 0) worldName = 'overworld';
    else if (worldId === 1) worldName = 'wasteland';
    else if (worldId === 2) worldName = 'desert';
    
    const worldSeed = `${masterSeed}_${worldName}`;
    setSeed(worldSeed.split('').reduce((a, b) => { a = ((a << 5) - a) + b.charCodeAt(0); return a & a }, 0));

    worldState.worldObjects = []; worldState.enemies = []; worldState.decorations = []; worldState.baseDecorations = []; worldState.activeBursts = [];

    generateBase();
    const cols = world.width / world.gridSize;
    const rows = world.height / world.gridSize;
    worldState.tileMap = Array.from({ length: rows }, () => Array(cols).fill(null));

    const isWasteland = worldId === 1;
    const isDesert = worldId === 2;
    const buffer = 3 * world.gridSize;

    const makeBlob = (type, count) => {
        for(let i = 0; i < count; i++) {
            let blob = new Set();
            const sx = Math.floor(seededRng() * cols);
            const sy = Math.floor(seededRng() * rows);
            if(isInsideRect(sx * world.gridSize, sy * world.gridSize, worldState.base)) continue;
            blob.add(`${sx},${sy}`);
            let q = [[sx, sy]];
            for(let j = 0; j < seededRng() * 20 + 10; j++) {
                if(q.length === 0) break;
                let [cx, cy] = q.shift();
                const n = [[0,1],[0,-1],[1,0],[-1,0]];
                for(const [dx, dy] of n) {
                    const nx = cx + dx;
                    const ny = cy + dy;
                    if(nx >= 0 && nx < cols && ny >= 0 && ny < rows && seededRng() > 0.4 && !blob.has(`${nx},${ny}`) && !isInsideRect(nx * world.gridSize, ny * world.gridSize, worldState.base)) {
                        blob.add(`${nx},${ny}`);
                        q.push([nx, ny]);
                    }
                }
            }
            blob.forEach(b => {
                const [bx, by] = b.split(',').map(Number);
                const isInRing = !isWasteland && !isDesert && (bx * world.gridSize < world.chunkSize || bx * world.gridSize >= world.width - world.chunkSize || by * world.gridSize < world.chunkSize || by * world.gridSize >= world.height - world.chunkSize);
                if (type === TILE_TYPE.WATER) { worldState.tileMap[by][bx] = (isWasteland || isInRing) ? TILE_TYPE.DARK_WATER : TILE_TYPE.WATER; } 
                else { worldState.tileMap[by][bx] = type; }
            });
        }
    };

    if (isDesert) {
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                worldState.tileMap[y][x] = TILE_TYPE.SAND;
            }
        }
        makeBlob(TILE_TYPE.DIRT, 20);

        for (let i = 0; i < 40; i++) {
            const wallLength = Math.floor(seededRng() * 12) + 3;
            let startX = Math.floor(seededRng() * cols);
            let startY = Math.floor(seededRng() * rows);
            const direction = seededRng();

            for (let j = 0; j < wallLength; j++) {
                if (startX >= 0 && startX < cols && startY >= 0 && startY < rows) {
                    const worldX = startX * world.gridSize;
                    const worldY = startY * world.gridSize;
                    if (!isInsideRect(worldX, worldY, worldState.base) && (worldX > buffer && worldX < world.width - buffer && worldY > buffer && worldY < world.height - buffer)) {
                        const speckles = Array.from({length: 10}, () => ({x: seededRng() * world.gridSize, y: seededRng() * world.gridSize, size: seededRng() * 2 + 1}));
                        worldState.worldObjects.push({ type: 'block', x: worldX, y: worldY, width: world.gridSize, height: world.gridSize, hits: 0, cracks: null, speckles });
                    }
                }
                if (direction < 0.33) startX++;
                else if (direction < 0.66) startY++;
                else { startX++; startY++; }
            }
        }
        for (let i = 0; i < 200; i++) {
            const worldX = seededRng() * world.width;
            const worldY = seededRng() * world.height;
            if (!isInsideRect(worldX, worldY, worldState.base) && (worldX > buffer && worldX < world.width - buffer && worldY > buffer && worldY < world.height - buffer)) {
                 if (seededRng() < 0.08) worldState.worldObjects.push({ type: 'deadBush', x: worldX, y: worldY, size: world.gridSize });
            }
        }
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                const worldX = x * world.gridSize;
                const worldY = y * world.gridSize;
                const tile = worldState.tileMap[y][x];
                 if (isInsideRect(worldX, worldY, worldState.base)) continue;
                if (tile === TILE_TYPE.SAND || tile === TILE_TYPE.DIRT) {
                    if (seededRng() < 0.5) { worldState.decorations.push({x: worldX + seededRng() * world.gridSize, y: worldY + seededRng() * world.gridSize, angle: seededRng() * Math.PI, length: seededRng() * 10 + 5, dark: false}); }
                }
            }
        }
    } else { // Overworld and Wasteland terrain generation
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                const worldX = x * world.gridSize;
                const worldY = y * world.gridSize;
                const isInRing = !isWasteland && (worldX < world.chunkSize || worldX >= world.width - world.chunkSize || worldY < world.chunkSize || worldY >= world.height - world.chunkSize);
                worldState.tileMap[y][x] = (isWasteland || isInRing) ? TILE_TYPE.DARK_GRASS : TILE_TYPE.GRASS;
            }
        }
        
        makeBlob(TILE_TYPE.WATER, 15);
        makeBlob(TILE_TYPE.SAND, 20);

        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                const worldX = x * world.gridSize;
                const worldY = y * world.gridSize;
                if (isInsideRect(worldX, worldY, worldState.base)) continue;

                const tile = worldState.tileMap[y][x];
                const isWater = tile === TILE_TYPE.WATER || tile === TILE_TYPE.DARK_WATER;
                if (!isWater) {
                    const isDark = tile === TILE_TYPE.DARK_GRASS;
                    if (seededRng() < 0.5) { worldState.decorations.push({x: worldX + seededRng() * world.gridSize, y: worldY + seededRng() * world.gridSize, angle: seededRng() * Math.PI, length: seededRng() * 10 + 5, dark: isDark}); }
                }
                
                if (worldX > buffer && worldX < world.width - buffer && worldY > buffer && worldY < world.height - buffer) {
                    const isInRing = !isWasteland && (worldX < world.chunkSize || worldX >= world.width - world.chunkSize || worldY < world.chunkSize || worldY >= world.height - world.chunkSize);
                    if (isWasteland || isInRing) {
                        if (seededRng() < 0.008) worldState.worldObjects.push({ type: 'deadBush', x: worldX, y: worldY, size: world.gridSize });
                    } else {
                        if (seededRng() < 0.005) {
                            const speckles = Array.from({length: 10}, () => ({x: seededRng() * world.gridSize, y: seededRng() * world.gridSize, size: seededRng() * 2 + 1}));
                            worldState.worldObjects.push({ type: 'block', x: worldX, y: worldY, width: world.gridSize, height: world.gridSize, hits: 0, cracks: null, speckles });
                        } else if (seededRng() < 0.008) {
                            const leafyDetails = Array.from({length: 3}, () => ({x: (seededRng() - 0.5) * 15, y: (seededRng() - 0.5) * 15, r: world.gridSize / 8}));
                            worldState.worldObjects.push({ type: 'tree', x: worldX, y: worldY, size: world.gridSize, hits: 0, leafyDetails });
                        }
                    }
                }
            }
        }
    }

    // Universal Enemy Spawning Logic
    if (isWasteland) {
        spawnEnemies(70, {x_min: 0, y_min: 0, x_max: world.width, y_max: world.height - world.chunkSize}, 0.7, [], 0.05, 0);
        spawnEnemies(10, {x_min: 0, y_min: world.height - world.chunkSize, x_max: world.width, y_max: world.height}, 0.1, [], 0, 0);
    } else if (isDesert) {
        const fullZone = {x_min: 0, y_min: 0, x_max: world.width, y_max: world.height};
        const totalEnemies = 80;
        const superEliteCount = Math.floor(totalEnemies * 0.4);
        const eliteCount = Math.floor(totalEnemies * 0.4);
        const juggernautCount = Math.floor(totalEnemies * 0.1);
        const normalCount = totalEnemies - superEliteCount - eliteCount - juggernautCount;

        spawnEnemies(superEliteCount, fullZone, 0, [], 0, 1);
        spawnEnemies(eliteCount, fullZone, 1, [], 0, 0);
        spawnEnemies(juggernautCount, fullZone, 0, [], 1, 0);
        spawnEnemies(normalCount, fullZone, 0, [], 0, 0);
    } else { // Overworld
        spawnEnemies(30, { x_min: world.chunkSize, y_min: world.chunkSize, x_max: world.width - world.chunkSize, y_max: world.height - world.chunkSize }, 0.1, [], 0, 0);
        spawnEnemies(50, {x_min: 0, y_min: 0, x_max: world.width, y_max: world.height}, 0.7, [{ x_min: world.chunkSize, y_min: world.chunkSize, x_max: world.width - world.chunkSize, y_max: world.height - world.chunkSize }], 0.01, 0);
    }
    
    // Universal Base Flooring
    const baseStartX = Math.floor(worldState.base.x / world.gridSize);
    const baseStartY = Math.floor(worldState.base.y / world.gridSize);
    const baseSizeInTiles = Math.ceil(worldState.base.size / world.gridSize);
    for (let y = baseStartY; y < baseStartY + baseSizeInTiles; y++) {
        for (let x = baseStartX; x < baseStartX + baseSizeInTiles; x++) {
            if (worldState.tileMap[y] && worldState.tileMap[y][x]) {
                worldState.tileMap[y][x] = TILE_TYPE.GRASS;
            }
        }
    }
}
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
function isInsideRect(x, y, rect) { return x >= rect.x && x < rect.x + rect.size && y >= rect.y && y < rect.y + rect.size; }
function isCollidingWithObject(x, y, width, height) { for (const obj of worldState.worldObjects) { if (obj.type === 'garage') continue; const objWidth = obj.size || obj.width; const objHeight = obj.size || obj.height; if (x < obj.x + objWidth && x + width > obj.x && y < obj.y + objHeight && y + height > obj.y) return true; } return false; }
function findValidSpawnPoint(x, y, width, height, isWorldTransition = false) { 
    if (!isCollidingWithObject(x, y, width, height)) return { x, y }; 
    for (let radius = 1; radius < 10; radius++) { 
        for (let i = 0; i < 8 * radius; i++) { 
            let testX, testY; 
            let angle = (i / (8 * radius)) * Math.PI * 2; 
            testX = x + Math.cos(angle) * radius * world.gridSize; 
            testY = y + Math.sin(angle) * radius * world.gridSize; 
            if (isWorldTransition) {
                if (currentWorldId === 1 && testY < world.gridSize) continue;
                if (currentWorldId === 0 && testY > world.height - world.gridSize) continue;
            }
            if (!isCollidingWithObject(testX, testY, width, height)) return { x: testX, y: testY }; 
        } 
    } 
    return { x, y }; 
}
function spawnEnemies(count, zone, eliteChance, exclusionZones = [], juggernautChance = 0, superEliteChance = 0) {
    const buffer = (currentWorldId === 1 || currentWorldId === 2 ? 4 : 8) * world.gridSize;
    const safeZone = { x: worldState.base.x - buffer, y: worldState.base.y - buffer, width: worldState.base.size + buffer * 2, height: worldState.base.size + buffer * 2 };
    for (let i = 0; i < count; i++) {
        let spawnX, spawnY; let isValid = false; let attempts = 0;
        while(!isValid && attempts < 50) {
            spawnX = zone.x_min + seededRng() * (zone.x_max - zone.x_min);
            spawnY = zone.y_min + seededRng() * (zone.y_max - zone.y_min);
            isValid = true;
            if (spawnX > safeZone.x && spawnX < safeZone.x + safeZone.width && spawnY > safeZone.y && spawnY < safeZone.y + safeZone.height) isValid = false;
            for(const exZone of exclusionZones) { if (spawnX >= exZone.x_min && spawnX < exZone.x_max && spawnY >= exZone.y_min && spawnY < exZone.y_max) { isValid = false; break; } }
            attempts++;
        }
        if(!isValid) continue;

        let enemy;
        const rand = seededRng();
        if (rand < superEliteChance) {
             enemy = { hp: 10, maxHp: 10, width: 40, height: 40, type: 'superElite', damage: 1, fireRate: 3500, aggroRange: 500, angle: 0, isHit: false, hitTime: 0, lastShotTime: 0, speed: 1.0 };
        } else if (rand < juggernautChance) {
            enemy = { hp: 20, maxHp: 20, width: 60, height: 60, type: 'juggernaut', damage: 0.25, fireRate: 125, aggroRange: 500, angle: 0, isHit: false, hitTime: 0, lastShotTime: 0, blockChance: 0.1, speed: 1.2, burstState: { active: false, startTime: 0, duration: 4000, cooldown: 2000 } };
        } else {
            const isElite = seededRng() < eliteChance;
            enemy = { hp: isElite ? 4 : 2, maxHp: isElite ? 4 : 2, width: isElite ? 40 : 35, height: isElite ? 40 : 35, type: isElite ? 'elite' : 'normal', damage: 1, fireRate: isElite ? 3500 : 4000, aggroRange: isElite ? 400 : 300, angle: 0, isHit: false, hitTime: 0, lastShotTime: 0, speed: 1.0 };
        }
        
        const validPos = findValidSpawnPoint(spawnX, spawnY, enemy.width, enemy.height);
        enemy.x = validPos.x; enemy.y = validPos.y;
        enemy.wanderBox = { x: validPos.x - 60, y: validPos.y - 60, width: 120, height: 120 };
        enemy.targetPos = { x: validPos.x, y: validPos.y };
        worldState.enemies.push(enemy);
    }
}
// --- 2.4 SPATIAL GRID LOGIC ---
class SpatialGrid {
    constructor(width, height, cellSize) {
        this.width = width;
        this.height = height;
        this.cellSize = cellSize;
        this.cols = Math.ceil(width / cellSize);
        this.rows = Math.ceil(height / cellSize);
        this.cells = new Map();
    }

    getKey(x, y) {
        return `${x},${y}`;
    }

    addToCell(obj, x, y) {
        const key = this.getKey(x, y);
        if (!this.cells.has(key)) {
            this.cells.set(key, []);
        }
        this.cells.get(key).push(obj);
    }

    add(obj) {
        const startX = Math.floor(obj.x / this.cellSize);
        const startY = Math.floor(obj.y / this.cellSize);
        const endX = Math.floor((obj.x + (obj.width || obj.size || 1)) / this.cellSize);
        const endY = Math.floor((obj.y + (obj.height || obj.size || 1)) / this.cellSize);

        for (let y = startY; y <= endY; y++) {
            for (let x = startX; x <= endX; x++) {
                this.addToCell(obj, x, y);
            }
        }
    }

    getNearby(x, y, width = 1, height = 1) {
        const nearby = new Set();
        const startX = Math.floor(x / this.cellSize);
        const startY = Math.floor(y / this.cellSize);
        const endX = Math.floor((x + width) / this.cellSize);
        const endY = Math.floor((y + height) / this.cellSize);

        for (let j = startY - 1; j <= endY + 1; j++) {
            for (let i = startX - 1; i <= endX + 1; i++) {
                const key = this.getKey(i, j);
                if (this.cells.has(key)) {
                    this.cells.get(key).forEach(obj => nearby.add(obj));
                }
            }
        }
        return Array.from(nearby);
    }
}

function updateSpatialGrid() {
    spatialGrid = new SpatialGrid(world.width, world.height, GRID_CELL_SIZE);
    worldState.worldObjects.forEach(obj => spatialGrid.add(obj));
    worldState.enemies.forEach(enemy => spatialGrid.add(enemy));
    if (player) spatialGrid.add(player);
}


function preGenerateAllFloorLoot() {
    console.log("Pre-generating all floor loot for new world...");
    const chunksX = world.width / world.chunkSize;
    const chunksY = world.height / world.chunkSize;

    // worldState.base is now guaranteed to exist because initWorldState() runs first.

    // Clear any existing floor loot before generating new loot. This is for backwards compatibility.
    worldState.pickups = worldState.pickups.filter(p => p.type === 'cashBag' || p.type === 'blueprint');

    for (let worldId = 0; worldId < 3; worldId++) { // Loop through Overworld, Wasteland, Desert
        for (let chunkY = 0; chunkY < chunksY; chunkY++) {
            for (let chunkX = 0; chunkX < chunksX; chunkX++) {
                if (Math.random() < 0.3) { // 30% chance to spawn loot
                    let chosenLoot;
                    const rand = Math.random();
                    
                    switch(worldId) {
                        case 0: // Overworld
                            if (rand < 0.325) chosenLoot = { type: 'money', value: 10 };
                            else if (rand < 0.65) chosenLoot = { type: 'heart' };
                            else if (rand < 0.85) chosenLoot = { type: 'money', value: 25 };
                            else if (rand < 0.95) chosenLoot = { type: 'money', value: 50 };
                            else chosenLoot = { type: 'money', value: 100 };
                            break;
                        case 1: // Wasteland
                            if (rand < 0.325) chosenLoot = { type: 'money', value: 100 };
                            else if (rand < 0.65) chosenLoot = { type: 'heart' };
                            else if (rand < 0.85) chosenLoot = { type: 'money', value: 250 };
                            else if (rand < 0.95) chosenLoot = { type: 'money', value: 500 };
                            else chosenLoot = { type: 'money', value: 1000 };
                            break;
                        case 2: // Desert
                            if (rand < 0.325) chosenLoot = { type: 'money', value: 1000 };
                            else if (rand < 0.65) chosenLoot = { type: 'blueHeart' };
                            else if (rand < 0.85) chosenLoot = { type: 'money', value: 2500 };
                            else if (rand < 0.95) chosenLoot = { type: 'money', value: 10000 };
                            else chosenLoot = { type: 'money', value: 25000 };
                            break;
                    }

                    const spawnX = chunkX * world.chunkSize + Math.random() * world.chunkSize;
                    const spawnY = chunkY * world.chunkSize + Math.random() * world.chunkSize;

                    if (!isInsideRect(spawnX, spawnY, worldState.base)) {
                        if (chosenLoot.type === 'heart') {
                            worldState.pickups.push({type:'heart', x: spawnX, y: spawnY, radius: 15, worldId: worldId });
                        } else if (chosenLoot.type === 'blueHeart') {
                            worldState.pickups.push({type:'blueHeart', x: spawnX, y: spawnY, radius: 18, worldId: worldId });
                        } else {
                            worldState.pickups.push({type:'money', value: chosenLoot.value, x: spawnX, y: spawnY, radius: 10, worldId: worldId });
                        }
                    }
                }
            }
        }
    }
    console.log(`Loot generation complete. Total items: ${worldState.pickups.length}`);
}

async function changeWorld(newWorldId, spawnX = null, spawnY = null) {
    if (isTransitioning) return;
    isTransitioning = true;
    const overlay = document.getElementById('transition-overlay');
    overlay.style.opacity = '1';
    
    await new Promise(resolve => setTimeout(resolve, 500));

    currentWorldId = newWorldId;
    manageAmbience();
    worldState.visitedChunks.clear();
    generateWorld(currentWorldId);

    let initialX, initialY;
    // Case 1: E/W Travel (spawnY is provided)
    if (spawnY !== null) {
        initialX = spawnX;
        initialY = spawnY;
    }
    // Case 2: N/S Travel (spawnX is provided, spawnY is null)
    else if (spawnX !== null) {
        initialX = spawnX;
        if (newWorldId === 1) { // Arriving in Wasteland
            initialY = world.height - player.height - world.gridSize;
        } else { // Arriving in Overworld from Wasteland
            initialY = world.gridSize;
        }
    }
    // Case 3: Default spawn (e.g., initial load, respawn)
    else {
        initialX = worldState.base.center.x - player.width / 2;
        initialY = worldState.base.center.y - player.height / 2;
    }
    
    const safePos = findValidSpawnPoint(initialX, initialY, player.width, player.height, true);
    player.x = safePos.x;
    player.y = safePos.y;

    const safeRadius = 16 * world.gridSize;
    worldState.enemies = worldState.enemies.filter(e => Math.hypot(e.x - player.x, e.y - player.y) > safeRadius);

    await new Promise(resolve => setTimeout(resolve, 100));
    overlay.style.opacity = '0';
    isTransitioning = false;
}

// --- CORE GAME LOGIC ---
function handlePlayerDeath() {
    if (player.isDead) return;
    player.isDead = true;

    worldState.enemies.forEach(e => e.isFollowing = false);
    worldState.activeFollowerCount = 0;

    if (!playerStats.hasSeenDeathTip && (player.moneyFloat > 0 || player.carryingBlueprints.length > 0)) {
        justDiedWithLoot = true;
    }

    player.deathTimestamps.push(Date.now());
    unlockAchievement('dieHard');
    
    const deathX = player.x, deathY = player.y;
    const moneyToDrop = Math.floor(player.moneyFloat);
    if (moneyToDrop > 0) {
        const cashBagPos = findValidSpawnPoint(deathX, deathY, world.gridSize, world.gridSize);
        const bagId = `bag_${Date.now()}`;
        worldState.pickups.push({type: 'cashBag', value: moneyToDrop, x: cashBagPos.x, y: cashBagPos.y, size: world.gridSize, id: bagId, worldId: currentWorldId });
        worldState.deathBags.unshift({id: bagId, x: cashBagPos.x, y: cashBagPos.y, worldId: currentWorldId});
        
        if(worldState.deathBags.length > 10) {
            const oldestBag = worldState.deathBags.pop();
            const pickupIndex = worldState.pickups.findIndex(p => p.id === oldestBag.id);
            if (pickupIndex > -1) {
                worldState.pickups.splice(pickupIndex, 1);
            }
        }
    }
    player.moneyFloat = 0;
    
    player.carryingBlueprints.forEach(bpId => {
        const bpPos = findValidSpawnPoint(deathX + (Math.random() - 0.5) * 40, deathY + (Math.random() - 0.5) * 40, 30, 30);
        worldState.pickups.push({type: 'blueprint', id: bpId, x: bpPos.x, y: bpPos.y, size: 30});
    });
    player.carryingBlueprints = [];
    
    openModal('death-modal');
}
function checkCollision(x, y, width = player.width, height = player.height) {
    // Overworld: Solid South and East walls. North and West are open for transitions.
    if (currentWorldId === 0) {
        if (y + height > world.height) return true;
        if (x + width > world.width) return true;
    } 
    // Wasteland: Solid North, East, and West walls. South is open.
    else if (currentWorldId === 1) {
        if (y < 0) return true;
        if (x < 0 || x + width > world.width) return true;
    }
    // Desert: Solid North, South, and West walls. East is open.
    else if (currentWorldId === 2) {
        if (y < 0 || y + height > world.height) return true;
        if (x < 0) return true;
    }
    
    return isCollidingWithObject(x, y, width, height);
}
function updatePlayer(deltaTime) {
    if (player.isDead || isGameBlocked) return;
    const now = Date.now();

    // N/S Travel (Priority)
    if (currentWorldId === 0 && player.y <= 0) {
        changeWorld(1, player.x);
        return;
    } else if (currentWorldId === 1 && player.y + player.height >= world.height) {
        changeWorld(0, player.x);
        return;
    }
	// E/W Travel
    else if (currentWorldId === 0 && player.x <= 0) {
        changeWorld(2, world.width - player.width - world.gridSize, player.y); // Go to Desert
        return;
    } else if (currentWorldId === 2 && player.x + player.width >= world.width) {
        changeWorld(0, world.gridSize, player.y); // Go to Overworld
        return;
    }


    const medBay = worldState.base.medBay;
    if(medBay.tier > 0) { const medBayData = medBayUpgrades[medBay.tier]; const medBayPad = worldState.base.medBay; const dist = Math.hypot((player.x + player.width/2) - (medBayPad.x + medBayPad.width/2), (player.y + player.height/2) - (medBayPad.y + medBayPad.height/2)); if(dist < world.gridSize * 1.2 && player.hp < player.maxHp) { const healInterval = 1000 / medBayData.heal; if (medBayData.heal > 0 && now - player.lastHealTickTime > healInterval) { player.hp = Math.min(player.maxHp, player.hp + 1); player.lastHealTickTime = now; playSound("pickup", "C5", "16n"); createHealParticle(player.x + player.width/2, player.y + player.height/2); } } }
    
    const garage = worldState.base.garage;
    const p_cx = player.x + player.width/2; 
    const p_cy = player.y + player.height/2;
    const inGarageZone = (garage.tier > 0 && p_cx > garage.x && p_cx < garage.x + garage.width && p_cy > garage.y && p_cy < garage.y + garage.height);
    
    if (inGarageZone) {
        if (player.canEnterGarage && !isPlayerInGarage) {
            isPlayerInGarage = true;
            manageAmbience();
            player.canEnterGarage = false;
            garageSelectedCategory = 'Turret'; 
            garageSelectedItemId = garageData[garageSelectedCategory][0]?.id;
            updateGarageUI();
            openModal('garage-modal');
            if (deviceMode === 'mobile') {
                document.getElementById('garage-ui-content').classList.add('mobile-slim');
            }
        }
    } else {
        player.canEnterGarage = true;
    }

    if (player.fabricated.nitroBoost && (keys.shift || touchState.boostTouchId !== null) && now - player.boost.lastUsed > player.boost.cooldown) {
        player.boost.isBoosting = true;
        player.boost.lastUsed = now;
        playUrlSound("nitro"); // Y1.6 Play nitro sound
    }
    if (player.boost.isBoosting && now - player.boost.lastUsed > 1000) {
        player.boost.isBoosting = false;
    }

    let dx = 0, dy = 0, targetSpeed = 0; const isTryingToMove = (touchState.moveStick.x !== 0 || touchState.moveStick.y !== 0) || keys.w || keys.a || keys.s || keys.d; if (isTryingToMove) { player.timeSpentMoving += deltaTime; if (touchState.moveStick.x !== 0 || touchState.moveStick.y !== 0) { dx = touchState.moveStick.x; dy = touchState.moveStick.y; } else { if (keys.w) dy -= 1; if (keys.s) dy += 1; if (keys.a) dx -= 1; if (keys.d) dx += 1; } const dist = Math.hypot(dx, dy); if (dist > 0) { dx /= dist; dy /= dist; } const dot = (dx * player.prevDx) + (dy * player.prevDy); if (dot < -0.5) { player.pitchPenalty = 0.25; } player.prevDx = dx; player.prevDy = dy; player.bodyAngle = Math.atan2(dy, dx); targetSpeed = player.speed; } else { player.timeSpentMoving = 0; player.prevDx = 0; player.prevDy = 0; }
    if (touchState.aimStick.x !== 0 || touchState.aimStick.y !== 0) { player.turretAngle = Math.atan2(touchState.aimStick.y, touchState.aimStick.x); player.aimLine.active = true; player.aimLine.lastActiveTime = now; } else if (now - player.lastMouseMoveTime > 100) { let turretDX = 0, turretDY = 0; if (keys.arrowup) turretDY = -1; if (keys.arrowdown) turretDY = 1; if (keys.arrowleft) turretDX = -1; if (keys.arrowright) turretDX = 1; if (turretDX !== 0 || turretDY !== 0) { player.turretAngle = Math.atan2(turretDY, turretDX); player.aimLine.active = true; player.aimLine.lastActiveTime = now; } }
    
    const timeSinceAim = now - player.aimLine.lastActiveTime;
    if (timeSinceAim > 5000) player.aimLine.opacity = 0;
    else if (timeSinceAim > 3000) player.aimLine.opacity = 0.5;
    else player.aimLine.opacity = 1.0;


    let speedModifier = 1.0;
    if (player.boost.isBoosting) speedModifier *= 3;
    player.currentSpeed += (targetSpeed - player.currentSpeed) * player.acceleration; 
    
    const pCenterX = player.x + player.width/2, pCenterY = player.y + player.height/2; 
    const tileX = Math.floor(pCenterX / world.gridSize);
    const tileY = Math.floor(pCenterY / world.gridSize);
    let isActuallyInWater = false;
    let onSandTile = false;
    if (worldState.tileMap[tileY] && worldState.tileMap[tileY][tileX]) {
        const tile = worldState.tileMap[tileY][tileX];
        isActuallyInWater = tile === TILE_TYPE.WATER || tile === TILE_TYPE.DARK_WATER;
        onSandTile = tile === TILE_TYPE.SAND;
    }

    if (isActuallyInWater) speedModifier *= 0.25;
    if (onSandTile) speedModifier *= 0.60;

    const canPlaySplash = now - player.lastSplashSoundTime > 100;
    if (isActuallyInWater && !player.isInWater && canPlaySplash) { // Entering water
        playSound("splash");
        player.lastSplashSoundTime = now;
        createSplashParticles(pCenterX, pCenterY);
        player.lastSplashParticleTime = now;
    } else if (isActuallyInWater && isTryingToMove && now - player.lastSplashParticleTime > 1000) { // Moving in water
        playSound("splash");
        createSplashParticles(pCenterX, pCenterY);
        player.lastSplashParticleTime = now;
    }
    player.isInWater = isActuallyInWater;

    const finalSpeed = player.currentSpeed * speedModifier; if (Math.abs(finalSpeed) > 0.01) { const nextX = player.x + Math.cos(player.bodyAngle) * finalSpeed; const nextY = player.y + Math.sin(player.bodyAngle) * finalSpeed; if (!checkCollision(nextX, player.y)) player.x = nextX; if (!checkCollision(player.x, nextY)) player.y = nextY; }
    if (player.isHit && now - player.hitTime > 500) player.isHit = false;
    if (player.blockEffect.active && now - player.blockEffect.time > 500) player.blockEffect.active = false;
}
function updateShooting() {
    if (player.isDead || isPlayerInGarage || isGameBlocked) return;
    const now = Date.now();
    
    if (player.equipment.turret === 'machineGun') {
        if (player.mg.isReloading) {
            if (now - player.mg.lastReloadTime > player.mg.reloadTime) {
                player.mg.isReloading = false;
                player.mg.currentAmmo = player.mg.magSize;
            }
            return;
        }
        if (keys.r) {
            // New Reload Logic: Check if already reloading or mag is full
            if (!player.mg.isReloading && player.mg.currentAmmo < player.mg.magSize) {
                player.mg.isReloading = true;
                player.mg.lastReloadTime = now;
                playUrlSound("reload");
            }
            return;
        }
    }

    const isShooting = keys[' '] || touchState.fireTouchId !== null;
    if (isShooting) {
        player.aimLine.active = true;
        player.aimLine.lastActiveTime = now;
    }

    if (isShooting && now - player.lastShotTime > player.fireRate) {
        if (player.equipment.turret === 'machineGun' && player.mg.currentAmmo <= 0) {
            player.mg.isReloading = true;
            player.mg.lastReloadTime = now;
            playUrlSound("reload");
            return;
        }

        player.lastShotTime = now;
        if (player.equipment.turret === 'machineGun') {
            player.mg.currentAmmo--;
        }

        const burstDelay = player.equipment.turret === 'standardCannon' ? 100 : 0;
        worldState.activeBursts.push({ 
            owner: 'player', x: player.x + player.width / 2, y: player.y + player.height / 2, 
            angle: player.turretAngle, totalShots: player.burstCount, shotsFired: 0, 
            delay: burstDelay, nextShotTime: now, 
            bulletSpeed: player.bulletSpeed, bulletDamage: player.bulletDamage, ownerWidth: player.width 
        });
    }
}
function updateEnemies() {
    const now = Date.now();
    worldState.deadEnemies = worldState.deadEnemies.filter(de => now - de.time < 2000);
    for (const e of worldState.enemies) {
        const distToPlayer = Math.hypot(player.x - e.x, player.y - e.y);
        if (distToPlayer > camera.width * 1.5) {
            continue;
        }

        if (e.isHit && now - e.hitTime > 500) e.isHit = false;
        if (e.blockEffect && e.blockEffect.active && now - e.blockEffect.time > 500) e.blockEffect.active = false;
        
        if (!player.isDead && !isPlayerInGarage && distToPlayer < e.aggroRange) {
            e.angle = Math.atan2(player.y - e.y, player.x - e.x);

            // Follower Movement Logic
            if (e.type === 'juggernaut' || e.type === 'superElite') {
                if (!e.isFollowing && worldState.activeFollowerCount < 25) {
                    e.isFollowing = true;
                    worldState.activeFollowerCount++;
                }
                
                if (e.isFollowing) {
                    const nextX = e.x + Math.cos(e.angle) * e.speed;
                    const nextY = e.y + Math.sin(e.angle) * e.speed;
                    if (!isCollidingWithObject(nextX, e.y, e.width, e.height)) e.x = nextX;
                    if (!isCollidingWithObject(e.x, nextY, e.width, e.height)) e.y = nextY;
                }
            }

            // Shooting Logic
            if (e.type === 'juggernaut') {
                if (e.burstState.active) {
                    if (now - e.burstState.startTime > e.burstState.duration) {
                        e.burstState.active = false;
                        e.burstState.startTime = now;
                    } else if (now - e.lastShotTime > e.fireRate) {
                        e.lastShotTime = now;
                        worldState.bullets.push({ owner: e.type, x: e.x + e.width / 2, y: e.y + e.height / 2, dx: Math.cos(e.angle) * 6, dy: Math.sin(e.angle) * 6, radius: 6, damage: e.damage });
                    }
                } else {
                    if (now - e.burstState.startTime > e.burstState.cooldown) {
                        e.burstState.active = true;
                        e.burstState.startTime = now;
                    }
                }
            } else {
                if (now - e.lastShotTime > e.fireRate) {
                    e.lastShotTime = now;
                    let bulletCount = 1;
                    if (e.type === 'elite') bulletCount = 2;
                    if (e.type === 'superElite') bulletCount = 3;
                    
                    const burstDelay = 100;
                    worldState.activeBursts.push({ owner: e.type, x: e.x + e.width / 2, y: e.y + e.height / 2, angle: e.angle, totalShots: bulletCount, shotsFired: 0, delay: burstDelay, nextShotTime: now, bulletSpeed: 4, bulletDamage: e.damage, ownerWidth: e.width });
                }
            }
        } else {
            if (e.isFollowing) {
                e.isFollowing = false;
                worldState.activeFollowerCount--;
            }
            if (Math.hypot(e.x - e.targetPos.x, e.y - e.targetPos.y) < 10) {
                e.targetPos.x = e.wanderBox.x + Math.random() * e.wanderBox.width;
                e.targetPos.y = e.wanderBox.y + Math.random() * e.wanderBox.height;
            }
            e.angle = Math.atan2(e.targetPos.y - e.y, e.targetPos.x - e.x);
            e.x = clamp(e.x + Math.cos(e.angle) * 0.5, 0, world.width - e.width);
            e.y = clamp(e.y + Math.sin(e.angle) * 0.5, 0, world.height - e.height);
        }
    }
}
function updateBursts() { const now = Date.now(); for (let i = worldState.activeBursts.length - 1; i >= 0; i--) { const burst = worldState.activeBursts[i]; if (now >= burst.nextShotTime) { if ((burst.owner === 'player' && (player.isDead || isPlayerInGarage))) { worldState.activeBursts.splice(i, 1); continue; } playUrlSound("shoot", burst.owner); const spawnDist = burst.ownerWidth / 2; worldState.bullets.push({ owner: burst.owner, x: burst.x + Math.cos(burst.angle) * spawnDist, y: burst.y + Math.sin(burst.angle) * spawnDist, dx: Math.cos(burst.angle) * burst.bulletSpeed, dy: Math.sin(burst.angle) * burst.bulletSpeed, radius: burst.owner === 'player' ? 5 : 6, damage: burst.bulletDamage }); burst.shotsFired++; burst.nextShotTime = now + burst.delay; if (burst.shotsFired >= burst.totalShots) { worldState.activeBursts.splice(i, 1); } } } }
function dropLoot(x, y, enemyType) {
    // 3.3 Blueprint Hardening: Check if a blueprint already exists on the floor.
    const mgBlueprintOnFloor = worldState.pickups.some(p => p.type === 'blueprint' && p.id === 'machineGun');
    const nbBlueprintOnFloor = worldState.pickups.some(p => p.type === 'blueprint' && p.id === 'nitroBoost');

    if (enemyType === 'superElite') {
        const lootOptions = [
            {type: 'money', value: 500}, {type: 'money', value: 1000},
            {type: 'money', value: 3000}, {type: 'blueHeart'}
        ];
        const loot = lootOptions[Math.floor(Math.random() * lootOptions.length)];
        if (loot.type === 'money') {
            const validPos = findValidSpawnPoint(x, y, 24, 16);
            worldState.pickups.push({type:'money', value: loot.value, x: validPos.x, y: validPos.y, radius: 10});
        } else { 
            const validPos = findValidSpawnPoint(x, y, 35, 35);
            worldState.pickups.push({type:'blueHeart', x: validPos.x, y: validPos.y, radius: 18});
        }
        return;
    }

    // 3.3 Blueprint Hardening: Comprehensive check for Machine Gun blueprint
    if (enemyType === 'elite' && !player.fabricated.machineGun && !player.installedBlueprints.machineGun && player.carryingBlueprints.indexOf('machineGun') === -1 && !mgBlueprintOnFloor && Math.random() < 0.05) {
        const validPos = findValidSpawnPoint(x, y, 30, 30);
        worldState.pickups.push({type:'blueprint', id: 'machineGun', x: validPos.x, y: validPos.y, size: 30});
        return;
    }

    if (enemyType === 'juggernaut') {
        // 3.3 Blueprint Hardening: Comprehensive check for Nitro Boost blueprint
        if (!player.fabricated.nitroBoost && !player.installedBlueprints.nitroBoost && player.carryingBlueprints.indexOf('nitroBoost') === -1 && !nbBlueprintOnFloor && Math.random() < 0.25) {
            const validPos = findValidSpawnPoint(x, y, 30, 30);
            worldState.pickups.push({type:'blueprint', id: 'nitroBoost', x: validPos.x, y: validPos.y, size: 30});
            return;
        } else {
            const lootOptions = [
                {type: 'money', value: 500}, {type: 'money', value: 2000},
                {type: 'money', value: 2500}, {type: 'blueHeart'}
            ];
            const loot = lootOptions[Math.floor(Math.random() * lootOptions.length)];
            if (loot.type === 'money') {
                const validPos = findValidSpawnPoint(x, y, 24, 16);
                worldState.pickups.push({type:'money', value: loot.value, x: validPos.x, y: validPos.y, radius: 10});
            } else { 
                const validPos = findValidSpawnPoint(x, y, 35, 35);
                worldState.pickups.push({type:'blueHeart', x: validPos.x, y: validPos.y, radius: 18});
            }
            return;
        }
    }

    const rand = Math.random(); let loot; if (enemyType === 'elite') { if (rand < 0.33) loot = {type:'money', value: 50 }; else if (rand < 0.66) loot = {type:'money', value: 100 }; else loot = {type:'money', value: 500 }; } else { if (rand < 0.25) loot = {type:'money', value: 5 }; else if (rand < 0.5) loot = {type:'money', value: 10 }; else if (rand < 0.75) loot = {type:'money', value: 25 }; else loot = {type:'heart', count: 1 }; } if (loot.type === 'heart') { for (let i = 0; i < loot.count; i++) { const validPos = findValidSpawnPoint(x + (i * 20 - 10), y, 30, 30); worldState.pickups.push({type:'heart', x: validPos.x, y: validPos.y, radius: 15}); } } else { const validPos = findValidSpawnPoint(x, y, 24, 16); worldState.pickups.push({type:'money', value: loot.value, x: validPos.x, y: validPos.y, radius: 10}); } }
function updateBullets() {
    for (let i = worldState.bullets.length - 1; i >= 0; i--) {
        const b = worldState.bullets[i];
        if (!b) continue;

        b.x += b.dx;
        b.y += b.dy;

        // 1. Check if bullet is out of bounds
        if (b.x < camera.x - 100 || b.x > camera.x + camera.width + 100 || b.y < camera.y - 100 || b.y > camera.y + camera.height + 100) {
            worldState.bullets.splice(i, 1);
            continue;
        }

        let bulletDestroyed = false;
        const nearbyObjects = spatialGrid.getNearby(b.x, b.y);

        // 2. Check for target-specific collisions first
        if (b.owner === 'player') {
            const nearbyEnemies = nearbyObjects.filter(o => o.hp !== undefined && o !== player); // Ensure we don't hit ourselves or non-enemies
            for (const e of nearbyEnemies) {
                if (Math.hypot(b.x - (e.x + e.width / 2), b.y - (e.y + e.height / 2)) < (e.width / 2) * 1.2) {
                    if (e.type === 'superElite' && Math.random() < 0.3) {
                        playUrlSound("block");
                        e.blockEffect = { active: true, time: Date.now() };
                    } else {
                        playUrlSound("hit");
                        e.hp -= b.damage;
                        e.isHit = true;
                        e.hitTime = Date.now();
                        e.showHealthBarUntil = Date.now() + 10000;
                        if (e.hp <= 0) {
                            if (e.isFollowing) worldState.activeFollowerCount--;
                            playUrlSound("explode");
                            dropLoot(e.x, e.y, e.type);
                            playerStats.kills++;
                            player.killTimestamps.push(Date.now());
                            unlockAchievement('doubleKill');
                            unlockAchievement('tripleKill');
                            unlockAchievement('kilimanjaro');
                            worldState.deadEnemies.push({ data: { ...e }, time: Date.now() });
                            const enemyIndex = worldState.enemies.findIndex(en => en === e);
                            if (enemyIndex > -1) worldState.enemies.splice(enemyIndex, 1);
                        }
                    }
                    worldState.bullets.splice(i, 1);
                    bulletDestroyed = true;
                    break;
                }
            }
        } else { // Enemy bullets
            if (!player.isDead && !isPlayerInGarage && Math.hypot(b.x - (player.x + player.width / 2), b.y - (player.y + player.height / 2)) < player.width / 2) {
                if (Math.random() > player.blockChance) {
                    playSound("hurt", "A1", "8n");
                    player.hp -= b.damage;
                    player.isHit = true;
                    player.hitTime = Date.now();
                    document.getElementById('game-container').classList.add('shake');
                    setTimeout(() => document.getElementById('game-container').classList.remove('shake'), 200);
                } else {
                    playUrlSound("block");
                    player.blockEffect = { active: true, time: Date.now(), radius: 0 };
                }
                worldState.bullets.splice(i, 1);
                bulletDestroyed = true;
                if (player.hp <= 0 && !player.isDead) { // Death race condition fix
                    handlePlayerDeath();
                }
            }
        }
        if (bulletDestroyed) continue;

        // 3. If no target was hit, check for environmental collisions
        const nearbyWorldObjects = nearbyObjects.filter(o => o.hp === undefined && o !== player); // Filter out any living entities
        for (const obj of nearbyWorldObjects) {
            if (obj.type === 'garage' || obj.type === 'deadBush') continue;
            const objWidth = obj.size || obj.width;
            const objHeight = obj.size || obj.height;
            if (b.x > obj.x && b.x < obj.x + objWidth && b.y > obj.y && b.y < obj.y + objHeight) {
                playUrlSound("hit");
                obj.hits++;
                if (obj.type === 'tree' && obj.hits >= 5) { obj.type = 'deadBush'; }
                if (obj.type === 'block' && obj.hits >= 10) {
                    playSound("rockCrack");
                    if (!obj.cracks) {
                        obj.cracks = [];
                        for (let c = 0; c < 3; c++) obj.cracks.push({ x1: Math.random() * objWidth, y1: Math.random() * objHeight, x2: Math.random() * objWidth, y2: Math.random() * objHeight });
                    }
                }
                worldState.bullets.splice(i, 1);
                bulletDestroyed = true;
                break;
            }
        }
    }
}
function updatePickups(){ if(player.isDead || isPlayerInGarage)return; for(let i=worldState.pickups.length-1;i>=0;i--){ const p=worldState.pickups[i]; if (p.type === 'cashBag' && p.worldId !== currentWorldId) continue; const pickupWidth = p.width || p.size || p.radius * 2; const pickupHeight = p.height || p.size || p.radius * 2; if(player.x < p.x + pickupWidth && player.x + player.width > p.x && player.y < p.y + pickupHeight && player.y + player.height > p.y){ const now = Date.now(); if(now - lastPickupSoundTime > 50) { playSound("pickup","C5","16n"); lastPickupSoundTime = now; } if(p.type==='heart'&&player.hp<player.maxHp){ player.hp=Math.min(player.maxHp,player.hp+1); } else if(p.type==='money' || p.type === 'cashBag'){ player.moneyFloat+=p.value;playerStats.moneyEarned+=p.value; if(p.value === 5) unlockAchievement('fiveDollars'); if(p.type === 'cashBag') { worldState.deathBags = worldState.deathBags.filter(bag => bag.id !== p.id); } } else if (p.type === 'blueprint' && player.carryingBlueprints.indexOf(p.id) === -1) { player.carryingBlueprints.push(p.id); } else if (p.type === 'blueHeart') { player.hp = Math.min(player.maxHp, player.hp + 25); } worldState.pickups.splice(i, 1); } } }
function updateCamera() { if (player.isDead || isPlayerInGarage) return; camera.targetX = player.x - camera.width / 2; camera.targetY = player.y - camera.height / 2; camera.x += (camera.targetX - camera.x) * 0.1; camera.y += (camera.targetY - camera.y) * 0.1; if (camera.shake > 0) { camera.x += (Math.random() - 0.5) * camera.shake; camera.y += (Math.random() - 0.5) * camera.shake; camera.shake *= 0.9; } camera.x = clamp(camera.x, 0, world.width - camera.width); camera.y = clamp(camera.y, 0, world.height - camera.height); }
function updateBase(deltaTime) {
    if (isPlayerInGarage) return;
    let onPadId = null;
    for (const pad of worldState.base.pads) {
        const padRadius = world.gridSize * 0.5;
        const dist = Math.hypot((player.x + player.width/2) - (pad.x + world.gridSize/2), (player.y + player.height/2) - (pad.y + world.gridSize/2));
        if (dist < padRadius) {
            onPadId = pad.id;
            if (pad.id !== player.lastUpgradedPadId) {
                if (pad.type === 'cashBay') { const currentTier = worldState.base.cashBay.tier; if (currentTier < cashBayUpgrades.length) { const nextTier = cashBayUpgrades[currentTier]; if (player.moneyFloat >= nextTier.cost) { player.moneyFloat -= nextTier.cost; worldState.base.cashBay.tier++; player.lastUpgradedPadId = pad.id; } }
                } else if (pad.type === 'medBay') { const currentTier = worldState.base.medBay.tier; if (currentTier < medBayUpgrades.length -1) { const nextTierData = medBayUpgrades[currentTier + 1]; if (player.moneyFloat >= nextTierData.cost) { player.moneyFloat -= nextTierData.cost; worldState.base.medBay.tier++; if(nextTierData.maxHp > player.maxHp) { 
                    player.maxHp = nextTierData.maxHp; 
                } player.lastUpgradedPadId = pad.id; } }
                } else if (pad.type === 'garage') {
                    const garage = worldState.base.garage;
                    if (garage.tier === 0 && worldState.base.cashBay.tier >= 1 && worldState.base.medBay.tier >= 1) {
                        if (player.moneyFloat >= GARAGE_UNLOCK_COST) {
                            player.moneyFloat -= GARAGE_UNLOCK_COST;
                            garage.tier = 1;
                            player.canEnterGarage = false; // Prevent immediate re-entry
                            player.lastUpgradedPadId = pad.id;
                        }
                    }
                }
            }
            break;
        }
    }
    if (!onPadId) {
        const garage = worldState.base.garage;
        const p_cx = player.x + player.width/2; 
        const p_cy = player.y + player.height/2;
        const inGarageZone = (garage.tier > 0 && p_cx > garage.x && p_cx < garage.x + garage.width && p_cy > garage.y && p_cy < garage.y + garage.height);
        if (!inGarageZone) {
            player.lastUpgradedPadId = null;
        }
    }
}
function updateIncome(deltaTime) {
    if (isPlayerInGarage || player.isDead || !worldState.base.cashBay) return;
    const cashBay = worldState.base.cashBay;
    if (cashBay.tier === 0) return;

    const data = cashBayUpgrades[cashBay.tier - 1];
    if (!data) return;
    
    // Y1.3 Fix: Calculate income into temp variables and check for NaN before adding.
    const passiveIncomeThisFrame = (data.passive / 1000) * deltaTime;
    if (!isNaN(passiveIncomeThisFrame)) {
        player.moneyFloat += passiveIncomeThisFrame;
    }

    const p_cx = player.x + player.width/2; 
    const p_cy = player.y + player.height/2;
    const onPad = (p_cx > cashBay.x && p_cx < cashBay.x + cashBay.width && p_cy > cashBay.y && p_cy < cashBay.y + cashBay.height);
    
    player.isOnCashBay = onPad;

    if (onPad) {
        const activeBoost = data.active - data.passive;
        const activeIncomeThisFrame = (activeBoost / 1000) * deltaTime;
        if (!isNaN(activeIncomeThisFrame)) {
            player.moneyFloat += activeIncomeThisFrame;
        }

        if (Date.now() - player.lastMoneyParticleTime > 100) {
            createMoneyParticle(cashBay.x, cashBay.y);
            player.lastMoneyParticleTime = Date.now();
        }
    }
}

function createSplashParticles(x, y) { const color = 'rgba(0, 100, 255, 0.5)'; for (let i = 0; i < 8; i++) { const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 1.5 + 0.5; worldState.particles.push({ x, y, dx: Math.cos(angle) * speed, dy: Math.sin(angle) * speed, life: Math.random() * 30 + 20, color: color, radius: Math.random() * 2 + 1, type: 'splash' }); } }
function createHealParticle(x, y) { worldState.particles.push({ x, y, dx: (Math.random() - 0.5) * 0.3, dy: -(Math.random() * 0.8 + 0.8), life: Math.random() * 60 + 50, type: 'heal' }); }
function createMoneyParticle(x, y) { worldState.particles.push({ x: x + (Math.random() - 0.5) * world.gridSize * 2, y: y + (Math.random() - 0.5) * world.gridSize * 2, dx: (Math.random() - 0.5) * 0.5, dy: - (Math.random() * 0.5 + 0.5), life: Math.random() * 40 + 30, color: `rgba(251, 191, 36, ${Math.random() * 0.5 + 0.5})`, type: 'money' }); }
function updateParticles() { for (let i = worldState.particles.length - 1; i >= 0; i--) { const p = worldState.particles[i]; p.x += p.dx; p.y += p.dy; p.life--; if (p.life <= 0) { worldState.particles.splice(i, 1); } } }
function updateAchievements(deltaTime) {
    const now = Date.now();
    player.deathTimestamps = player.deathTimestamps.filter(t => t > now - 5 * 60 * 1000);
    player.killTimestamps = player.killTimestamps.filter(t => t > now - 15 * 1000);

    let diff = player.turretAngle - player.lastTurretAngle; if (diff > Math.PI) diff -= 2 * Math.PI; if (diff < -Math.PI) diff += 2 * Math.PI; const currentSpinDirection = Math.sign(diff); if (currentSpinDirection === player.turretSpinDirection && Math.abs(diff) > 0.01) { player.consistentSpinTimer += deltaTime; } else { player.consistentSpinTimer = 0; } if(Math.abs(diff) > 0.01) player.turretSpinDirection = currentSpinDirection; player.lastTurretAngle = player.turretAngle; if (player.consistentSpinTimer > 10000) unlockAchievement('spin'); if (player.moneyFloat >= 1000000000) unlockAchievement('billionaire');
}
function unlockAchievement(id) { 
    if (!achievements[id] || achievements[id].unlocked) return; 
    if (id === 'dieHard') { if (player.deathTimestamps.length < 5) return; } 
    if (id === 'doubleKill') { const recentKills = player.killTimestamps.filter(t => t > Date.now() - 3 * 1000); if (recentKills.length < 2) return; } 
    if (id === 'tripleKill') { const recentKills = player.killTimestamps.filter(t => t > Date.now() - 3 * 1000); if (recentKills.length < 3) return; } 
    if (id === 'kilimanjaro') { const recentKills = player.killTimestamps.filter(t => t > Date.now() - 10 * 1000); if (recentKills.length < 7) return; } 
    achievements[id].unlocked = true; 
    playerStats.unlockedAchievements.push(achievements[id]); 
    notificationQueue.push({type: 'achievement', text: achievements[id].name});
    updateAchievementsUI(); 
}

function showNotification(text) {
    const notif = document.getElementById('achievement-notification');
    notif.innerHTML = `<span>🏆</span><span>✅</span><span>: ${text}</span>`;
    
    requestAnimationFrame(() => {
        notif.style.opacity = '1';
        if (deviceMode === 'mobile') {
            const pauseBtn = document.getElementById('pause-btn');
            const pauseRect = pauseBtn.getBoundingClientRect();
            notif.style.top = `${pauseRect.top}px`;
            notif.style.left = `${pauseRect.left}px`;
            notif.style.transform = `translateY(${pauseRect.height + 5}px)`;
        } else {
            // PC: Centered animation
            notif.style.transform = 'translate(-50%, 10px)';
        }
    });

    setTimeout(() => {
        notif.style.opacity = '0';
        if (deviceMode === 'mobile') {
            notif.style.transform = 'translateY(-120%)';
        } else {
            // PC: Centered animation
            notif.style.transform = 'translate(-50%, -120%)';
        }
    }, 3000);
}

function updateNotifications() {
    if (notificationQueue.length > 0) {
        const notif = notificationQueue.shift();
        if (notif.type === 'achievement') {
            showNotification(notif.text);
        } else if (notif.type === 'info') {
            showInfoModal(notif.title, notif.text);
        }
    }
}

function updateAchievementsUI() {
    if (!achievements) initAchievements();
    const list = document.getElementById('achievements-list');
    const title = document.getElementById('achievements-title');
    const totalAchievements = Object.keys(achievements).length;
    const unlockedCount = Object.values(achievements).filter(a => a.unlocked).length;
    
    title.textContent = `ACHIEVEMENTS (${unlockedCount}/${totalAchievements})`;
    list.innerHTML = "";

    const unlocked = [];
    const locked = [];

    for (const id in achievements) {
        if (achievements[id].unlocked) {
            unlocked.push(achievements[id]);
        } else {
            locked.push(achievements[id]);
        }
    }

    unlocked.forEach(ach => {
        const li = document.createElement('li');
        li.className = 'achievement-item unlocked';
        li.innerHTML = `<h3>🏆 ${ach.name}</h3><p>${ach.description}</p>`;
        list.appendChild(li);
    });

    locked.forEach(ach => {
        const li = document.createElement('li');
        li.className = 'achievement-item locked';
        li.innerHTML = `<h3>🏆 ${ach.name}</h3><p>This achievement has not been unlocked yet.</p>`;
        list.appendChild(li);
    });
}
function updateHealthWarnings() { if (player.isDead) return; const now = Date.now(); if (player.hp <= 1) { if (now - player.last1HpSoundTime > 1000) { playSound("lowHealth", "A2", "2n"); player.last1HpSoundTime = now; } } else if (player.hp <= 2) { if (now - player.last2HpSoundTime > 2000) { playSound("lowHealth", "A2", "2n"); player.last2HpSoundTime = now; } } }
function formatMoney(amount) {
    if (amount >= 1000000) return (amount / 1000000).toFixed(1) + 'M'; // S1.2: Removed replace to fix jitter
    if (amount >= 1000) return (amount / 1000).toFixed(1) + 'k'; // S1.2: Removed replace to fix jitter
    return amount.toFixed(2);
}

// --- DRAW & UI UPDATES ---
function drawWorld() {
    const colors = { grass: '#48D43B', water: '#0000FF', block: '#E2E8F0', sand: '#FBE29B', base: '#374151', dark_grass: '#006400', dark_water: '#00008B', dirt: '#966919' };
    const startX = Math.floor(camera.x / world.gridSize);
    const endX = Math.ceil((camera.x + camera.width) / world.gridSize);
    const startY = Math.floor(camera.y / world.gridSize);
    const endY = Math.ceil((camera.y + camera.height) / world.gridSize);

    let baseColor = currentWorldId === 1 ? colors.dark_grass : colors.grass;
    ctx.fillStyle = baseColor;
    ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

    for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
            if (worldState.tileMap[y] && worldState.tileMap[y][x]) {
                const tile = worldState.tileMap[y][x];
                let color;
                switch(tile) {
                    case TILE_TYPE.DARK_GRASS: color = colors.dark_grass; break;
                    case TILE_TYPE.SAND: color = colors.sand; break;
                    case TILE_TYPE.WATER: color = colors.water; break;
                    case TILE_TYPE.DARK_WATER: color = colors.dark_water; break;
                    case TILE_TYPE.DIRT: color = colors.dirt; break;
                }
                if (color && color !== baseColor) {
                    ctx.fillStyle = color;
                    ctx.fillRect(x * world.gridSize, y * world.gridSize, world.gridSize + 1, world.gridSize + 1);
                }
            }
        }
    }
    
    let decorationsDrawn = 0;
    const maxDecorations = 500;
    for(const d of worldState.decorations) {
        if (decorationsDrawn > maxDecorations) break;
        if (d.x > camera.x - 20 && d.x < camera.x + camera.width + 20 && d.y > camera.y - 20 && d.y < camera.y + camera.height + 20) { 
            ctx.strokeStyle = d.dark ? 'rgba(0,0,0,0.4)' : 'rgba(0,0,0,0.2)'; 
            ctx.lineWidth = 2; 
            ctx.save(); 
            ctx.translate(d.x, d.y); 
            ctx.rotate(d.angle); 
            ctx.beginPath(); 
            ctx.moveTo(0, -d.length/2); 
            ctx.lineTo(0, d.length/2); 
            ctx.stroke(); 
            ctx.restore(); 
            decorationsDrawn++;
        } 
    }

    if (worldState.base.x) { ctx.fillStyle = colors.base; ctx.fillRect(worldState.base.x, worldState.base.y, worldState.base.size, worldState.base.size); for(const d of worldState.baseDecorations) { ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 2; ctx.save(); ctx.translate(d.x, d.y); ctx.rotate(d.angle); ctx.beginPath(); ctx.moveTo(0, -d.length/2); ctx.lineTo(0, d.length/2); ctx.stroke(); ctx.restore(); } }
    for (const obj of worldState.worldObjects) { if (obj.x > camera.x - 50 && obj.x < camera.x + camera.width + 50 && obj.y > camera.y - 50 && obj.y < camera.y + camera.height + 50) { if (obj.type === 'block') { drawCrackedBlock(obj.x, obj.y, obj.width, obj.height, colors.block, obj.cracks, obj.speckles); } else if (obj.type === 'tree') { drawTree(obj.x, obj.y, obj.size, obj.leafyDetails); } else if (obj.type === 'deadBush') { drawDeadBush(obj.x, obj.y, obj.size); } } }
    if(worldState.base.cashBay && worldState.base.cashBay.tier > 0) { const cb = worldState.base.cashBay; drawCashBay(cb.x, cb.y, cb.width, cb.height); }
    if(worldState.base.garage && worldState.base.garage.tier > 0) { const g = worldState.base.garage; drawGarage(g.x, g.y, g.width, g.height); }
    if(worldState.base.medBay && worldState.base.medBay.tier > 0) { const mb = worldState.base.medBay; drawMedBayPad(mb.x, mb.y, mb.width, mb.height); }
}
function drawDynamicElements() {
    for (const p of worldState.pickups) {
        if (p.type === 'cashBag' && p.worldId !== currentWorldId) continue;

        if (p.type === 'money') { ctx.strokeStyle = 'black'; ctx.lineWidth = 4; ctx.strokeRect(p.x - 12, p.y - 8, 24, 16); ctx.fillStyle = '#22c55e'; ctx.fillRect(p.x - 12, p.y - 8, 24, 16); ctx.fillStyle='white'; ctx.font='bold 12px Inter'; ctx.textAlign = 'center'; ctx.fillText(`$${p.value}`, p.x, p.y+4); } else if (p.type === 'heart') { drawStroked(() => { ctx.fillStyle = '#e11d48'; ctx.beginPath(); ctx.moveTo(p.x, p.y - p.radius / 2); ctx.bezierCurveTo(p.x, p.y - p.radius, p.x - p.radius, p.y - p.radius, p.x - p.radius, p.y); ctx.bezierCurveTo(p.x - p.radius, p.y + p.radius / 2, p.x, p.y + p.radius, p.x, p.y + p.radius); ctx.bezierCurveTo(p.x, p.y + p.radius, p.x + p.radius, p.y + p.radius / 2, p.x + p.radius, p.y); ctx.bezierCurveTo(p.x + p.radius, p.y - p.radius, p.x, p.y - p.radius, p.x, p.y - p.radius / 2); ctx.fill(); }); } else if (p.type === 'cashBag') { drawCashBag(p.x, p.y, p.size); } else if (p.type === 'blueprint') { drawBlueprint(p.x, p.y, p.size, p.id); } else if (p.type === 'blueHeart') { drawBlueHeart(p.x, p.y, p.radius); } 
    }
    for (const p of worldState.particles) { ctx.globalAlpha = p.life / 100; if (p.type === 'splash') { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill(); } else if (p.type === 'money') { ctx.fillStyle = p.color; ctx.font = 'bold 16px Inter'; ctx.textAlign = 'center'; ctx.fillText('$', p.x, p.y); } else if (p.type === 'heal') { ctx.fillStyle = '#22c55e'; ctx.font = 'bold 24px Inter'; ctx.textAlign = 'center'; ctx.fillText('+', p.x, p.y); } ctx.globalAlpha = 1.0; }
    for (const b of worldState.bullets) { ctx.fillStyle='black';ctx.beginPath();ctx.arc(b.x,b.y,b.radius,0,Math.PI*2);ctx.fill();ctx.fillStyle=b.owner==='player'?'#FBBF24':'#f472b6';ctx.beginPath();ctx.arc(b.x,b.y,b.radius-2,0,Math.PI*2);ctx.fill(); }
for (const e of worldState.enemies) {
        let bodyColor, turretColor;
        if (e.type === 'superElite') {
            bodyColor = '#3b82f6'; // Baby Blue
            turretColor = '#facc15';
        } else if (e.type === 'juggernaut') {
            bodyColor = '#4a044e';
            turretColor = '#a21caf';
        } else if (e.type === 'elite') {
            bodyColor = '#991b1b';
            turretColor = '#facc15';
		} else {
            bodyColor = '#7f1d1d';
            turretColor = '#718096';
        }
        drawTank(e.x, e.y, e.width, e.height, e.angle, e.angle, bodyColor, turretColor, e.isHit, false, e.type);

        if (e.blockEffect && e.blockEffect.active) {
            const elapsed = Date.now() - e.blockEffect.time;
            const progress = elapsed / 500;
            const radius = 20 + progress * 40;
            const alpha = 1 - progress;
            ctx.strokeStyle = `rgba(59, 130, 246, ${alpha})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(e.x + e.width/2, e.y + e.height/2, radius, 0, Math.PI * 2);
            ctx.stroke();
        }

        if (e.showHealthBarUntil && e.showHealthBarUntil > Date.now()) {
            const barWidth = e.width * 0.8;
            const barHeight = 8;
            const barX = e.x + (e.width - barWidth) / 2;
            const barY = e.y - 15;
            const healthPercent = e.hp / e.maxHp;
            ctx.fillStyle = 'black';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            ctx.fillStyle = '#22c55e';
            ctx.fillRect(barX + 2, barY + 2, (barWidth - 4) * healthPercent, barHeight - 4);
        }
    }
}
function drawOnscreenUI() {
    // --- Baked-in UI Text ---
    ctx.save();
    ctx.textAlign = 'center';
    ctx.textShadow = '1px 1px 2px black';

    if (worldState.base.cashBay && worldState.base.cashBay.tier > 0) {
        const cashBay = worldState.base.cashBay;
        const data = cashBayUpgrades[cashBay.tier - 1];
        const incomeText = `${formatMoney(data.passive).replace('.00','')}-${formatMoney(data.active).replace('.00','')}/s`;
        ctx.font = 'bold 16px Inter';
        ctx.fillStyle = 'white';
        ctx.fillText('CASH BAY', cashBay.x + cashBay.width / 2, cashBay.y - 25);
        ctx.font = '14px Inter';
        ctx.fillText(`Level ${cashBay.tier}: $${incomeText}`, cashBay.x + cashBay.width / 2, cashBay.y - 8);
    }
     if (worldState.base.medBay && worldState.base.medBay.tier > 0) {
        const medBay = worldState.base.medBay;
        const data = medBayUpgrades[medBay.tier];
        ctx.font = 'bold 16px Inter';
        ctx.fillStyle = 'white';
        ctx.fillText('MED BAY', medBay.x + medBay.width / 2, medBay.y - 25);
        ctx.font = '14px Inter';
        ctx.fillText(`Level ${medBay.tier}: ${data.heal} hp/s, max: ${data.maxHp}`, medBay.x + medBay.width / 2, medBay.y - 8);
    }
    if (worldState.base.garage && worldState.base.garage.tier > 0) {
        const garage = worldState.base.garage;
        ctx.font = 'bold 16px Inter';
        ctx.fillStyle = 'white';
        ctx.fillText('GARAGE', garage.x + garage.width / 2, garage.y - 15);
    }

    const cashPad = worldState.base.pads.find(p => p.type === 'cashBay');
    const cashPadTier = worldState.base.cashBay.tier;
    if (cashPadTier < cashBayUpgrades.length) {
        const cost = cashBayUpgrades[cashPadTier].cost;
        if (cashPadTier === 0) {
            ctx.font = 'bold 16px Inter';
            ctx.fillStyle = 'white';
            ctx.fillText('Purchase Cash Bay', cashPad.x + world.gridSize / 2, cashPad.y + world.gridSize + 15);
            ctx.font = '14px Inter';
            ctx.fillStyle = '#fbbf24';
            ctx.fillText(`Cost: $${formatMoney(cost)}`, cashPad.x + world.gridSize / 2, cashPad.y + world.gridSize + 35);
        } else {
            ctx.font = 'bold 16px Inter';
            ctx.fillStyle = '#fbbf24';
            ctx.fillText(`Upgrade: $${formatMoney(cost)}`, cashPad.x + world.gridSize / 2, cashPad.y + world.gridSize + 25);
        }
    }

    const medPad = worldState.base.pads.find(p => p.type === 'medBay');
    const medPadTier = worldState.base.medBay.tier;
    if (medPadTier < medBayUpgrades.length - 1) {
        const cost = medBayUpgrades[medPadTier + 1].cost;
        if (medPadTier === 0) {
            ctx.font = 'bold 16px Inter';
            ctx.fillStyle = 'white';
            ctx.fillText('Purchase Med Bay', medPad.x + world.gridSize / 2, medPad.y + world.gridSize + 15);
            ctx.font = '14px Inter';
            ctx.fillStyle = '#fbbf24';
            ctx.fillText(`Cost: $${formatMoney(cost)}`, medPad.x + world.gridSize / 2, medPad.y + world.gridSize + 35);
        } else {
            ctx.font = 'bold 16px Inter';
            ctx.fillStyle = '#fbbf24';
            ctx.fillText(`Upgrade: $${formatMoney(cost)}`, medPad.x + world.gridSize / 2, medPad.y + world.gridSize + 25);
        }
    }

    const garagePad = worldState.base.pads.find(p => p.type === 'garage');
    if (worldState.base.garage.tier === 0 && worldState.base.cashBay.tier >= 1 && worldState.base.medBay.tier >= 1) {
        ctx.font = 'bold 16px Inter';
        ctx.fillStyle = 'white';
        ctx.fillText('Purchase Garage', garagePad.x + world.gridSize / 2, garagePad.y + world.gridSize + 15);
        ctx.font = '14px Inter';
        ctx.fillStyle = '#fbbf24';
        ctx.fillText(`Cost: $${formatMoney(GARAGE_UNLOCK_COST)}`, garagePad.x + world.gridSize / 2, garagePad.y + world.gridSize + 35);
    }
    ctx.restore();

    if (worldState.base.pads) { for (const pad of worldState.base.pads) { if (pad.type === 'garage' && (worldState.base.garage.tier > 0 || worldState.base.cashBay.tier < 1 || worldState.base.medBay.tier < 1)) continue; if ((pad.type === 'cashBay' && worldState.base.cashBay.tier === cashBayUpgrades.length) || (pad.type === 'medBay' && worldState.base.medBay.tier === medBayUpgrades.length -1)) continue; const radius = world.gridSize * 0.4; let canAfford = false; if (pad.type === 'cashBay') { const tier = worldState.base.cashBay.tier; canAfford = player.moneyFloat >= cashBayUpgrades[tier].cost; } else if (pad.type === 'medBay') { const tier = worldState.base.medBay.tier; canAfford = player.moneyFloat >= medBayUpgrades[tier+1].cost; } else if (pad.type === 'garage') { canAfford = player.moneyFloat >= GARAGE_UNLOCK_COST; } if (canAfford) { ctx.fillStyle = '#16a34a'; ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 + Math.sin(Date.now() / 200) * 0.5})`; ctx.lineWidth = 4; } else { ctx.fillStyle = '#b91c1c'; ctx.strokeStyle = 'black'; ctx.lineWidth = 2; } ctx.beginPath(); ctx.arc(pad.x + world.gridSize / 2, pad.y + world.gridSize / 2, radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); } }
}
function drawPingLine(startX, startY, endX, endY, color, text) {
    const angle = Math.atan2(endY - startY, endX - startX);
    const dist = Math.hypot(endX - startX, endY - startY);
    
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(endX, endY);
    ctx.stroke();

    // Draw arrows
    const arrowSpacing = 3 * world.gridSize; // Every 3 tiles
    for (let d = arrowSpacing; d < dist; d += arrowSpacing) {
        const x = startX + Math.cos(angle) * d;
        const y = startY + Math.sin(angle) * d;
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(-10, -5);
        ctx.lineTo(0, 0);
        ctx.lineTo(-10, 5);
        ctx.stroke();
        ctx.restore();
    }

    // Draw text
    ctx.font = 'bold 20px Inter';
    ctx.textAlign = 'center';
    ctx.shadowColor = 'black';
    ctx.shadowBlur = 4;
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 4;
    ctx.strokeText(text, startX + Math.cos(angle) * 100, startY + Math.sin(angle) * 100 - 20);
    ctx.fillStyle = color;
    ctx.fillText(text, startX + Math.cos(angle) * 100, startY + Math.sin(angle) * 100 - 20);
}
function drawPlayerAndPings() {
    const now = Date.now();
    const p_cx = player.x + player.width / 2;
    const p_cy = player.y + player.height / 2;
    
    // --- PING LINES ---
    worldState.pings = worldState.pings.filter(p => p.endTime > now);
    for (const ping of worldState.pings) {
        const timeRemaining = ping.endTime - now;
        const alpha = timeRemaining < 1000 ? (timeRemaining / 1000) : 1.0;
        
        ctx.save();
        ctx.globalAlpha = alpha;
        const dist = Math.hypot(ping.endX - p_cx, ping.endY - p_cy);
        const text = `${ping.label} ${Math.round(dist / world.gridSize * 10)}m`;
        drawPingLine(p_cx, p_cy, ping.endX, ping.endY, ping.color, text);
        ctx.restore();
    }
    
    // --- AIM LINE ---
    ctx.save();
    if (!isPlayerInGarage && player.aimLine.active && player.aimLine.opacity > 0) {
        const endX = p_cx + Math.cos(player.turretAngle) * (world.gridSize * 5);
        const endY = p_cy + Math.sin(player.turretAngle) * (world.gridSize * 5);
        
        ctx.globalAlpha = player.aimLine.opacity;
        ctx.beginPath();
        ctx.moveTo(p_cx, p_cy);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = `rgba(0,0,0, ${player.aimLine.opacity})`;
        ctx.lineWidth = 3;
        ctx.stroke();
    }
    ctx.restore();

    // --- PLAYER TANK ---
    if (!player.isDead && !isPlayerInGarage) {
        drawTank(player.x, player.y, player.width, player.height, player.bodyAngle, player.turretAngle, "#A0AEC0", "#718096", player.isHit, player.boost.isBoosting);
        if (player.blockEffect.active) {
            const elapsed = Date.now() - player.blockEffect.time;
            const progress = elapsed / 500;
            const radius = 20 + progress * 40;
            const alpha = 1 - progress;
            ctx.strokeStyle = `rgba(59, 130, 246, ${alpha})`;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(player.x + player.width/2, player.y + player.height/2, radius, 0, Math.PI * 2);
            ctx.stroke();
        }
    }
}
function draw() {
    const rect = canvas.getBoundingClientRect();
    if (isPingSpyVisible) pingSpyLog = [];
    
    ctx.clearRect(0, 0, rect.width, rect.height);
    ctx.save();
    ctx.scale(camera.zoom, camera.zoom);
    ctx.translate(-camera.x, -camera.y);
    
    drawWorld();
    drawDynamicElements();
    drawOnscreenUI();
    drawPlayerAndPings();

    ctx.restore();

    if (isPingSpyVisible) {
        document.getElementById('ping-spy-panel').innerHTML = pingSpyLog.join('<br>');
    }
}
function updateUI() {
    const isMobile = deviceMode === 'mobile';
    let moneyDisplay, healthDisplay, ammoDisplay, blueprintDisplay;

    document.getElementById('game-version-display').style.display = isVersionVisible ? 'block' : 'none';

    if (isMobile) {
        const mobileContainer = document.getElementById('mobile-ui-container');
        moneyDisplay = mobileContainer.querySelector('#money-display');
        healthDisplay = mobileContainer.querySelector('#health-display');
        ammoDisplay = mobileContainer.querySelector('#ammo-display');
        blueprintDisplay = mobileContainer.querySelector('#blueprint-display');
    } else {
        moneyDisplay = document.querySelector('.desktop-header .header-right #money-display');
        healthDisplay = document.querySelector('.desktop-header .header-right #health-display');
        ammoDisplay = document.querySelector('.desktop-header .header-right #ammo-display');
        blueprintDisplay = document.querySelector('.desktop-header .header-right #blueprint-display');
    }

    moneyDisplay.classList.toggle('money-pulse', player.isOnCashBay);
    moneyDisplay.textContent = `$${formatMoney(player.moneyFloat)}`;

    const hpDisplayVal = Number.isInteger(player.hp) ? player.hp : player.hp.toFixed(1);
    healthDisplay.textContent = `${hpDisplayVal}/${player.maxHp} HP`;
    
    if (player.carryingBlueprints.length > 0) {
        blueprintDisplay.style.display = 'flex';
        blueprintDisplay.innerHTML = player.carryingBlueprints.map(id => {
            if (id === 'machineGun') return '<span>📃MG</span>';
            if (id === 'nitroBoost') return '<span>📃NB</span>';
            return '';
        }).join('');
    } else {
        blueprintDisplay.style.display = 'none';
    }

    document.getElementById('boost-btn').style.display = player.fabricated.nitroBoost ? 'flex' : 'none';
    
    const indicatorYellow = document.getElementById('shoot-indicator-yellow'), indicatorGreen = document.getElementById('shoot-indicator-green');
    if (player.equipment.turret === 'machineGun') {
        ammoDisplay.style.display = 'block';
        document.getElementById('reload-btn').style.display = 'block';
        if (player.mg.isReloading) {
            ammoDisplay.textContent = 'Reloading...';
            const reloadProgress = (Date.now() - player.mg.lastReloadTime) / player.mg.reloadTime;
            indicatorYellow.style.backgroundColor = reloadProgress > 0.9 ? '#facc15' : '#1a202c';
            indicatorGreen.style.backgroundColor = '#1a202c';
        } else {
            ammoDisplay.textContent = `${player.mg.currentAmmo}/${player.mg.magSize}`;
            if (player.mg.currentAmmo === 0) {
                 indicatorYellow.style.backgroundColor = '#1a202c';
                 indicatorGreen.style.backgroundColor = '#1a202c';
            } else {
                indicatorYellow.style.backgroundColor = '#facc15';
                indicatorGreen.style.backgroundColor = '#22c55e';
            }
        }
    } else {
        ammoDisplay.style.display = 'none';
        document.getElementById('reload-btn').style.display = 'none';
        const cooldownProgress = (Date.now() - player.lastShotTime) / player.fireRate;
        if (cooldownProgress >= 1) { indicatorYellow.style.backgroundColor = '#facc15'; indicatorYellow.style.boxShadow = '0 0 8px #facc15'; indicatorGreen.style.backgroundColor = '#22c55e'; indicatorGreen.style.boxShadow = '0 0 8px #22c55e'; } else if (cooldownProgress >= 0.8) { indicatorYellow.style.backgroundColor = '#facc15'; indicatorYellow.style.boxShadow = '0 0 8px #facc15'; indicatorGreen.style.backgroundColor = '#1a202c'; indicatorGreen.style.boxShadow = 'none'; } else { indicatorYellow.style.backgroundColor = '#1a202c'; indicatorGreen.style.backgroundColor = '#1a202c'; indicatorYellow.style.boxShadow = 'none'; indicatorGreen.style.boxShadow = 'none'; }
    }
    
    healthDisplay.classList.toggle('health-pulse', player.hp <= (player.maxHp * 0.25) && !player.isDead);
    if (isDebugVisible) { const debugPanel = document.getElementById('debug-panel'); debugPanel.innerHTML = `World: ${currentWorldId === 0 ? 'Overworld' : 'Wasteland'}<br>Juggernauts: ${worldState.enemies.filter(e => e.type === 'juggernaut').length}<br>Cannon: ${player.cannonTier}<br>Engine: ${player.engineTier}<br>Armor: ${player.armorTier}`; }
}
function updateWeaponStats() {
    if (!player) return;
    if (player.equipment.turret === 'standardCannon') {
        const upgrade = garageStandardCannonUpgrades[player.cannonTier - 1];
        player.fireRate = 1000;
        player.bulletDamage = upgrade.stats['Damage'];
        player.bulletSpeed = (upgrade.stats['Bullet Speed'] / 100) * 6; // Convert % to base speed
        player.burstCount = upgrade.stats['Fire Rate'] > 1 ? upgrade.stats['Fire Rate'] : 1;
    } else if (player.equipment.turret === 'machineGun') {
        player.fireRate = 125;
        player.bulletDamage = 0.30;
        player.bulletSpeed = 8;
        player.burstCount = 1;
    }
}
function updatePlayerStatsFromUpgrades() {
    if (!player) return;
    if (player.armorTier > 0) {
        const armorTierData = garageArmorUpgrades[player.armorTier - 1];
        player.blockChance = armorTierData.stats['Block Chance'];
    } else {
        player.blockChance = 0;
    }
        const engineTierData = garageEngineUpgrades[player.engineTier - 1];
    player.speed = (engineTierData.stats['Speed'] / 100) * 1.94;
}

// --- W1.4 SAVE/LOAD SYSTEM & SEEDED RNG ---
let seededRng;
function setSeed(seed) {
    // Simple Mulberry32 algorithm
    seededRng = () => {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}

function saveGame() {
    try {
        // Y1.2 Fix: Prevent NaN from ever being saved.
        const moneyToSave = isNaN(player.moneyFloat) ? 0 : player.moneyFloat;

        const saveData = {
            timestamp: Date.now(),
            masterSeed: masterSeed,
            moneyFloat: moneyToSave,
            hp: player.hp,
            maxHp: player.maxHp,
            cannonTier: player.cannonTier,
            engineTier: player.engineTier,
            armorTier: player.armorTier,
            blueprints: player.blueprints,
            fabricated: player.fabricated,
            installedBlueprints: player.installedBlueprints,
            carryingBlueprints: player.carryingBlueprints,
            equipment: player.equipment,
            cashBayTier: worldState.base.cashBay?.tier ?? 0,
            medBayTier: worldState.base.medBay?.tier ?? 0,
            garageTier: worldState.base.garage?.tier ?? 0,
            currentWorldId: currentWorldId,
            playerX: player.x,
            playerY: player.y,
            playerStats: playerStats,
            achievements: achievements,
            // Y1.2 Feature: Persist death bags and pickups
            deathBags: worldState.deathBags,
            pickups: worldState.pickups
        };
        localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
        console.log(`Game saved.`);
        return true;
    } catch (e) {
        console.error("Failed to save game:", e);
        return false;
    }
}

function loadGame() {
    try {
        const savedData = localStorage.getItem(SAVE_KEY);
        if (!savedData) {
            console.error(`No save data found.`);
            return false;
        }
        const data = JSON.parse(savedData);
        
        initPlayerState(true); 
        initAchievements(); 

        masterSeed = data.masterSeed;
        
        // Y1.1 Fix: Robust NaN check for moneyFloat
        const loadedMoney = parseFloat(data.moneyFloat);
        player.moneyFloat = isNaN(loadedMoney) ? 0 : loadedMoney;

        player.maxHp = data.maxHp;
        player.hp = data.hp;
        player.cannonTier = data.cannonTier;
        player.engineTier = data.engineTier;
        player.armorTier = data.armorTier;
        player.blueprints = data.blueprints;
        player.fabricated = data.fabricated;
        player.installedBlueprints = data.installedBlueprints;
        player.carryingBlueprints = data.carryingBlueprints || [];
        player.equipment = data.equipment;
        player.x = data.playerX;
        player.y = data.playerY;
        playerStats = data.playerStats;
        if (playerStats && !playerStats.hasOwnProperty('hasSeenDeathTip')) {
            playerStats.hasSeenDeathTip = false;
        }
        achievements = data.achievements;
        
        currentWorldId = data.currentWorldId;
        generateWorld(currentWorldId); 

        // Y1.2 Feature: Load persisted death bags and pickups
        worldState.deathBags = data.deathBags || [];
        worldState.pickups = data.pickups || [];

        // 3.1 Backwards compatibility: If an old save has no floor loot, generate it.
        if (!worldState.pickups.some(p => p.type === 'money' || p.type === 'heart')) {
            preGenerateAllFloorLoot();
        }

        worldState.base.cashBay.tier = data.cashBayTier;
        worldState.base.medBay.tier = data.medBayTier;
        worldState.base.garage.tier = data.garageTier;

        updateWeaponStats();
        updatePlayerStatsFromUpgrades();
        
        return true;
    } catch (e) {
        console.error("Failed to load game:", e);
        showInfoModal("Load Error", "The save file may be corrupted. Starting a new game is recommended.");
        return false;
    }
}

function startNewGame() {
    masterSeed = Date.now(); // Simple unique seed
    initAchievements();
    initPlayerState(true);
    initWorldState(); // Initialize world and seed RNG first
    preGenerateAllFloorLoot(); // Then generate loot using the new seed
    saveGame();
}

function deleteSave() {
    try {
        localStorage.removeItem(SAVE_KEY);
        console.log("Save file deleted.");
    } catch (e) {
        console.error("Failed to delete save:", e);
    }
}

// Obsolete save slot functions removed in Y1.0

// R2.0: Garage UI Logic
function getGarageTierKey(itemId) { if (itemId === 'standardCannon') return 'cannonTier'; if (itemId === 'engine') return 'engineTier'; if (itemId === 'armor') return 'armorTier'; return null; }
function updateGarageUI() {
    const categoryNav = document.getElementById('category-nav');
    const itemListContainer = document.getElementById('item-list');
    const itemDetailsContainer = document.getElementById('item-details');

    categoryNav.innerHTML = '';
    Object.keys(garageData).forEach(category => {
        const button = document.createElement('button');
        button.textContent = category;
        button.className = `category-btn btn flex-1 md:w-full text-center md:text-left text-lg font-semibold py-2 md:py-3 px-3 md:px-5 rounded-lg border-b-4 md:border-b-0 md:border-l-4 border-transparent ${category === garageSelectedCategory ? 'active' : 'bg-gray-700 hover:bg-gray-600'}`;
        button.dataset.category = category;
        categoryNav.appendChild(button);
    });

    itemListContainer.innerHTML = '';
    garageData[garageSelectedCategory].forEach(item => {
        const card = document.createElement('div');
        card.className = `item-card cursor-pointer p-4 rounded-lg border-2 hover:border-blue-500 hover:bg-gray-700/50 flex flex-col justify-between text-center ${item.id === garageSelectedItemId ? 'selected' : ''}`;
        card.dataset.itemId = item.id;
        let statusHtml = '';
        if (player.equipment.turret === item.id || player.equipment.attachment === item.id) { statusHtml = `<span class="item-card-tag text-xl">✅</span>`; } 
        else if (item.type === 'blueprint' && !player.fabricated[item.id]) { statusHtml = `<span class="item-card-tag text-xs font-bold bg-red-900/50 px-2 py-1 rounded-full">🔒</span>`; }
        let tierText = '';
        if (item.type === 'upgrade') { const tier = player[getGarageTierKey(item.id)]; tierText = item.id === 'armor' && tier === 0 ? 'Not Owned' : (item.id === 'armor' ? `Tier ${tier}` : `Mk. ${tier}`); } 
        else { const hasBlueprint = player.blueprints[item.id] || player.carryingBlueprints.includes(item.id); tierText = player.fabricated[item.id] ? 'Fabricated' : (player.installedBlueprints[item.id] ? 'Ready to Fabricate' : (hasBlueprint ? 'Blueprint Owned' : 'Blueprint Required')); }
        card.innerHTML = `${statusHtml}<div class="flex-grow flex flex-col justify-center"><h3 class="font-bold text-lg pr-6">${item.name}</h3><p class="text-sm text-gray-400 pr-6">${tierText}</p></div>`;
        itemListContainer.appendChild(card);
    });

    const item = garageData[garageSelectedCategory].find(i => i.id === garageSelectedItemId);
    if (!item) { itemDetailsContainer.innerHTML = `<div class="text-center text-gray-500"><p class="text-lg">Select an item to see details</p></div>`; return; }
    let detailsHtml = '', currentTitle = '', currentDesc = '', currentStats = {}, maxStats = item.maxStats;
    if (item.type === 'upgrade') {
        const tierKey = getGarageTierKey(item.id);
        const currentTier = player[tierKey];
        const tierIndex = Math.max(0, currentTier - 1);
        let tierData;

        if (item.id === 'armor' && currentTier === 0) {
            currentTitle = "No Armor Plating";
            currentDesc = "Your chassis is exposed. Upgrade to add armor.";
            currentStats = { 'Block Chance': 0 };
        } else {
            tierData = item.upgrades[tierIndex];
            currentTitle = tierData.title;
            currentDesc = tierData.description;
            currentStats = tierData.stats;
        }

        const isMax = currentTier >= item.upgrades.length;
        const nextUpgrade = isMax ? null : item.upgrades[currentTier];
        const nextUpgradeEffectText = isMax ? 'MAX TIER' : (tierData ? tierData.nextUpgradeEffect : item.upgrades[0].description);

        let equipButtonHtml = '';
        if (item.id === 'standardCannon') { equipButtonHtml = `<button data-action="equip" data-item-id="${item.id}" class="btn w-full ${player.equipment.turret === item.id ? 'bg-green-800 text-green-300' : 'bg-blue-600 hover:bg-blue-500 text-white'}" ${player.equipment.turret === item.id ? 'disabled' : ''}>${player.equipment.turret === item.id ? 'EQUIPPED' : 'EQUIP'}</button>`; }
        const upgradeButton = `<button data-action="upgrade" data-item-id="${item.id}" class="btn w-full bg-green-600 border-green-800 hover:bg-green-500 text-white py-3" ${isMax || (nextUpgrade && player.moneyFloat < nextUpgrade.cost) ? 'disabled' : ''}><span class="upgrade-btn-content"><span>${isMax ? 'MAX TIER' : `UPGRADE ($${nextUpgrade.cost.toLocaleString()})`}</span><span class="upgrade-btn-effect">${nextUpgradeEffectText}</span></span></button>`;
        detailsHtml = `<div class="grid grid-cols-1 ${equipButtonHtml ? 'md:grid-cols-2' : ''} gap-4">${upgradeButton}${equipButtonHtml}</div>`;
    } else if (item.type === 'blueprint') {
        const bp = item.blueprint; currentTitle = bp.title; currentDesc = bp.description; if(item.id !== 'nitroBoost') currentStats = bp.stats;
        let buttonHtml;
        if (player.fabricated[item.id]) { const isEquipped = player.equipment.turret === item.id || player.equipment.attachment === item.id; buttonHtml = `<button data-action="equip" data-item-id="${item.id}" class="btn w-full ${isEquipped ? 'bg-green-800 text-green-300' : 'bg-blue-600 hover:bg-blue-500'}" ${isEquipped ? 'disabled' : ''}>${isEquipped ? 'EQUIPPED' : (item.id === 'nitroBoost' && player.equipment.attachment ? 'UNEQUIP' : 'EQUIP')}</button>`;
        } else if (player.installedBlueprints[item.id]) { buttonHtml = `<button data-action="fabricate" data-item-id="${item.id}" class="btn w-full bg-cyan-600 border-cyan-800 hover:bg-cyan-500 py-3" ${player.moneyFloat < bp.cost ? 'disabled' : ''}>FABRICATE ($${bp.cost.toLocaleString()})</button>`;
        } else if (player.blueprints[item.id] || player.carryingBlueprints.includes(item.id)) { buttonHtml = `<button data-action="install" data-item-id="${item.id}" class="btn w-full bg-purple-600 border-purple-800 hover:bg-purple-500 py-3">INSTALL BLUEPRINT</button>`;
        } else { buttonHtml = `<button class="btn w-full py-3" disabled>BLUEPRINT REQUIRED</button>`; }
        detailsHtml = `<div class="grid grid-cols-1 gap-4">${buttonHtml}</div>`;
    }
    let statsHtml = '';
    if (Object.keys(currentStats).length > 0) { for (const [stat, value] of Object.entries(currentStats)) { const globalMax = GLOBAL_MAX_STATS[stat]; const maxValue = globalMax !== undefined ? globalMax : (maxStats ? maxStats[stat] : value); const barWidth = maxValue > 0 ? (value / maxValue) * 100 : 0; let displayValue = value; if (stat === 'Block Chance') displayValue = (value * 100).toFixed(0) + '%'; else if (stat === 'Speed' || stat === 'Bullet Speed') displayValue = value + '%'; statsHtml += `<div class="stat-row"><span class="stat-label">${stat}</span><span class="stat-value">${displayValue}</span><div class="stat-bar-bg"><div class="stat-bar-fill" style="width: ${barWidth}%;"></div></div></div>`; } }
    itemDetailsContainer.innerHTML = `<h2 class="text-2xl md:text-3xl font-bold mb-2">${currentTitle}</h2><p class="text-gray-400 mb-4">${currentDesc}</p><div class="space-y-2 mb-6">${statsHtml}</div>${detailsHtml}`;

    document.querySelectorAll('.tank-part').forEach(part => part.classList.remove('highlighted')); 
    const category = garageSelectedCategory.toLowerCase();
    const desktopPart = document.getElementById(`desktop-svg-${category}`); 
    const mobilePart = document.getElementById(`mobile-svg-${category}`);
    if (desktopPart) desktopPart.classList.add('highlighted'); 
    if (mobilePart) mobilePart.classList.add('highlighted');
}

// --- GAME LOOP ---
function gameLoop(timestamp) {
    if (isLoading) { animationFrameId = requestAnimationFrame(gameLoop); return; }
    if (isRespawning) {
        initPlayerState(false); 
        player.x = worldState.base.center.x - player.width/2; 
        player.y = worldState.base.center.y - player.height/2; 
        isRespawning = false;

        if (justDiedWithLoot) {
            isGameBlocked = true;
            showInfoModal('Tip', "Use the 📍 button to ping the location of your dropped cash bag.");
            playerStats.hasSeenDeathTip = true;
            justDiedWithLoot = false;
        }
    }

    if (isPaused || isTransitioning) { lastTime = timestamp; animationFrameId = requestAnimationFrame(gameLoop); return; }
    if (!lastTime) lastTime = timestamp;
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    if (isConsoleVisible) {
        document.getElementById('on-screen-console').textContent = `dT: ${deltaTime.toFixed(2)}ms`;
    }
    
// X1.2: Silent, more frequent autosave
    if (!isPlayerInGarage && timestamp - lastAutosaveTime > 15000) { // Autosave every 15 seconds
        lastAutosaveTime = timestamp;
        saveGame(0); // Pass slot 0 for single save
    }
    
    updateSpatialGrid();

    if (!isPlayerInGarage) {
        updatePlayer(deltaTime);
        updateShooting();
        updatePickups();
        updateCamera();
        updateEnemies();
        updateBullets();
        updateBursts();
        updateBase(deltaTime);
        updateAchievements(deltaTime);
    } else {
        camera.x += (camera.targetX - camera.x) * 0.1;
        camera.y += (camera.targetY - camera.y) * 0.1;
    }
    
    updateIncome(deltaTime);
    updateEngineSound(deltaTime);
    updateParticles();
    updateHealthWarnings();
    updateNotifications();
    
    draw();
    updateUI();
    
    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- INPUT & SETUP ---
function handleBackAction() {
    if (modalStack.length === 0) return;

    const lastModalId = modalStack.pop();
    const lastModal = document.getElementById(lastModalId);
    if (lastModal) lastModal.style.display = 'none';

    // If we just closed the death modal, trigger respawn and stop.
    if (lastModalId === 'death-modal') {
        unlockAchievement('respawn');
        isRespawning = true;
        return; 
    }

    if (lastModalId === 'info-modal') {
        isGameBlocked = false;
    }

    // If we just closed the garage, update the player state
    if (lastModalId === 'garage-modal') {
        isPlayerInGarage = false;
        manageAmbience();
    }

    if (modalStack.length > 0) {
        const newTopModalId = modalStack[modalStack.length - 1];
        const newTopModal = document.getElementById(newTopModalId);
        if (newTopModal) newTopModal.style.display = 'flex';
    } else if (isPaused) {
        // If the stack is now empty AND the game was paused, unpause it.
        isPaused = false;
        manageAmbience();
    }
}

function showInfoModal(title, text) {
    document.getElementById('info-modal-title').textContent = title;
    document.getElementById('info-modal-text').textContent = text;
    openModal('info-modal');
}
let globalListenersAttached = false;
function setupGlobalListeners() {
    if (globalListenersAttached) return;

    const eventType = ('ontouchstart' in window) ? 'touchend' : 'click';
    const addSafeEventListener = (elementId, handler, event = eventType) => { const element = document.getElementById(elementId); if (element) element.addEventListener(event, (e) => { e.preventDefault(); handler(e); }, { passive: false }); };

    document.body.addEventListener(eventType, (e) => {
        if (e.target.closest('.modal-button, .utility-btn, .start-btn, .btn, .item-card, .category-btn')) {
            if (sfx && sfx.uiClick && sfx.uiClick.loaded) {
                if (sfx.uiClick.state === "started") sfx.uiClick.stop();
                sfx.uiClick.start();
            }
        }
    }, { passive: false });

    const toggleMasterAudio = () => {
        if (!isAudioInitialized) return;
        isMuted = !isMuted;
        Tone.getDestination().mute = isMuted;
        updateAudioToggleUI();
    };

    const consoleCheckbox = document.getElementById('toggle-console-checkbox');
    if (consoleCheckbox) {
        consoleCheckbox.addEventListener('change', (e) => {
            isConsoleVisible = e.target.checked;
            document.getElementById('on-screen-console').style.display = isConsoleVisible ? 'block' : 'none';
        });
    }

    document.getElementById('pc-controls-list').innerHTML = `
        <p><span class="font-bold text-yellow-300">W,A,S,D:</span> Move</p>
        <p><span class="font-bold text-yellow-300">Arrows/Mouse:</span> Aim</p>
        <p><span class="font-bold text-yellow-300">Space/Click:</span> Fire</p>
        <p><span class="font-bold text-yellow-300">R:</span> Reload</p>
        <p><span class="font-bold text-yellow-300">Shift:</span> Boost</p>
        <p><span class="font-bold text-yellow-300">Q:</span> Toggle Zoom</p>
        <p><span class="font-bold text-yellow-300">Middle Click:</span> Ping</p>
        <p><span class="font-bold text-yellow-300">Esc:</span> Pause</p>
    `;

    const eventMappings = {
        'main-menu-options-btn': async () => {
            await initAudio();
            const saveExistsForOptions = localStorage.getItem(SAVE_KEY) !== null;
            document.getElementById('options-delete-world-btn').style.display = saveExistsForOptions ? 'block' : 'none';
            openModal('options-modal');
        },
        'info-modal-close': handleBackAction,
        'pause-btn': () => {
            if (player.isDead) return;
            isPaused = true; 
            manageAmbience(); 
            document.getElementById('autosave-confirm-text').textContent = '';
            if (saveGame()) {
                document.getElementById('autosave-confirm-text').textContent = '(Successfully autosaved.)';
            }
            openModal('pause-modal'); 
        },
        'resume-btn': handleBackAction,
        'admin-menu-btn': () => openModal('admin-tools-modal'),
        'achievements-btn': () => { updateAchievementsUI(); openModal('achievements-modal'); },
        'options-achievements-btn': () => { updateAchievementsUI(); openModal('achievements-modal'); },
        'achievements-back-btn': handleBackAction,
        'main-menu-btn': () => { window.location.reload(); },
        'restart-confirm-yes': () => { window.location.reload(); },
        'restart-confirm-no': handleBackAction,
        'admin-tools-exit': handleBackAction,
        'admin-hp-1': () => { player.hp = 1; },
        'admin-money-0': () => { player.moneyFloat = 0; },
        'admin-give-mg-bp': () => { if(player.carryingBlueprints.indexOf('machineGun') === -1) player.carryingBlueprints.push('machineGun'); },
		'admin-give-nb-bp': () => { if(player.carryingBlueprints.indexOf('nitroBoost') === -1) player.carryingBlueprints.push('nitroBoost'); },
        'admin-spawn-jugg': () => { spawnEnemies(1, {x_min: player.x - 200, y_min: player.y - 200, x_max: player.x + 200, y_max: player.y + 200}, 0, [], 1, 0); },
        'admin-spawn-set': () => { spawnEnemies(1, {x_min: player.x - 200, y_min: player.y - 200, x_max: player.x + 200, y_max: player.y + 200}, 0, [], 0, 1); },
        'admin-max-base': () => {
             worldState.base.cashBay.tier = 10;
             worldState.base.medBay.tier = 10;
             worldState.base.garage.tier = 1;
             player.moneyFloat += 100000000;
             const medBayData = medBayUpgrades[worldState.base.medBay.tier];
             player.maxHp = medBayData.maxHp;
             player.hp = player.maxHp;
        },
        'options-controls-btn': () => openModal('pc-controls-modal'),
        'pc-controls-back-btn': handleBackAction,
        'garage-exit-btn': handleBackAction,
        'mobile-garage-exit-btn': handleBackAction,
        'admin-respawn': () => { handleBackAction(); handleBackAction(); player.hp = 0; handlePlayerDeath(); },
        'respawn-btn': () => {
            unlockAchievement('respawn');
            isRespawning = true;
            handleBackAction();
        },
        'pause-options-btn': () => {
            const saveExists = localStorage.getItem(SAVE_KEY) !== null;
            document.getElementById('options-delete-world-btn').style.display = saveExists ? 'block' : 'none';
            openModal('options-modal');
        },
        'options-back-btn': handleBackAction,
        'options-delete-world-btn': showStartOverConfirmation,
        'start-over-confirm-yes': () => {
            deleteSave();
            document.getElementById('options-delete-world-btn').style.display = 'none';
            handleBackAction();
            if (isPaused) {
                window.location.reload();
            } else {
                showStartScreen();
            }
        },
        'start-over-confirm-no': handleBackAction,
        'options-audio-toggle': toggleMasterAudio,
    };

    for (const id in eventMappings) {
        addSafeEventListener(id, eventMappings[id]);
    }
    
    document.querySelectorAll('.modal').forEach(modal => {
        modal.addEventListener(eventType, (e) => { 
            if (e.target === modal && modal.id !== 'death-modal') {
                handleBackAction();
            } 
        });
    });
    
    window.addEventListener('keydown', (e) => { 
        const key = e.key.toLowerCase();
        if (keys && keys.hasOwnProperty(key)) {
            keys[key] = true;
        }
        if (key === 'q' && deviceMode === 'desktop') {
             const zoomBtn = document.getElementById('zoom-btn');
             if (zoomBtn) zoomBtn.click();
        } 
        if (key === 'escape') {
            if (modalStack.length > 0 && modalStack[modalStack.length - 1] !== 'death-modal') {
                handleBackAction();
            } else if (player && !isPlayerInGarage && !player.isDead) {
                const pauseBtn = document.getElementById('pause-btn');
                if (pauseBtn) pauseBtn.click();
            }
        } 
    }); 

    globalListenersAttached = true;
}

function setupInputs(isMobile) {
    const eventType = isMobile ? 'touchend' : 'click';

    const utilityContainer = document.getElementById('utility-buttons');
    if (isMobile) {
        utilityContainer.innerHTML = `
            <div id="zoom-btn" class="utility-btn">🔎</div>
            <div id="ping-base-btn" class="utility-btn">📍</div>
        `;
        
        const mobileUiContainer = document.getElementById('mobile-ui-container');
        mobileUiContainer.innerHTML = `
            <div id="money-display">$0</div>
            <div id="health-display">5/5 HP</div>
            <div id="ammo-display">32/32</div>
            <div id="blueprint-display"></div>
        `;
    } else {
        utilityContainer.innerHTML = `
            <div class="text-center">
                <div id="zoom-btn" class="utility-btn">🔎</div>
                <div class="utility-label">(Q)</div>
            </div>
            <div class="text-center">
                <div id="ping-base-btn" class="utility-btn">📍</div>
                <div class="utility-label">(MMB)</div>
            </div>
        `;
    }
    
    const zoomBtn = document.getElementById('zoom-btn');
    const pingBtn = document.getElementById('ping-base-btn');
    const toggleZoom = () => { camera.zoom = (camera.zoom === 1.0) ? 0.5 : 1.0; resizeCanvas(); };
    const triggerPing = () => { 
        const now = Date.now();
        if (now - lastPingTime < 1000) return;
        lastPingTime = now;
        
        worldState.pings = []; 

        const p_cx = player.x + player.width / 2;
        const p_cy = player.y + player.height / 2;
        
        const playLayeredPing = (pitch) => {
            if (!isAudioInitialized || isMuted) return;
            const pingSound = new Tone.Player("https://raw.githubusercontent.com/Spamfan/Audio-host/main/radar.mp3").toDestination();
            pingSound.volume.value = -10;
            pingSound.playbackRate = pitch;
            pingSound.autostart = true;
        };

        const base_cx = worldState.base.center.x;
        const base_cy = worldState.base.center.y;
        const base_dist = Math.hypot(base_cx - p_cx, base_cy - p_cy);
        worldState.pings.push({
            endX: base_cx, endY: base_cy,
            color: 'white', label: 'Base:',
            endTime: now + 1500
        });
        playLayeredPing(mapDistanceToPitch(base_dist));

        const bagColors = ['#3b82f6', '#ef4444', '#facc15'];
        
        const bagsInCurrentWorld = worldState.deathBags.filter(bag => bag.worldId === currentWorldId);

        bagsInCurrentWorld.slice(0, 3).forEach((bag, index) => {
            setTimeout(() => {
                const bag_dist = Math.hypot(bag.x - p_cx, bag.y - p_cy);
                 worldState.pings.push({
                    endX: bag.x, endY: bag.y,
                    color: bagColors[index], label: 'Loot:',
                    endTime: now + 1500
                });
                playLayeredPing(mapDistanceToPitch(bag_dist));
            }, (index + 1) * 100);
        });
    };
    
    const mapDistanceToPitch = (dist) => {
        const maxDist = Math.hypot(world.width, world.height);
        const ratio = Math.max(0, 1 - (dist / (maxDist / 2))); 
        return 0.8 + (ratio * 0.7);
    };

    zoomBtn.addEventListener(eventType, toggleZoom);
    pingBtn.addEventListener(eventType, triggerPing);
    
    document.getElementById('category-nav').addEventListener(eventType, (e) => { const button = e.target.closest('button[data-category]'); if (button) { garageSelectedCategory = button.dataset.category; garageSelectedItemId = garageData[garageSelectedCategory][0]?.id; updateGarageUI(); } });
    document.getElementById('item-list').addEventListener(eventType, (e) => { const card = e.target.closest('.item-card'); if (card) { garageSelectedItemId = card.dataset.itemId; updateGarageUI(); } });
    document.getElementById('item-details').addEventListener(eventType, (e) => {
        const button = e.target.closest('button[data-action]'); if (!button || button.disabled) return;
        const action = button.dataset.action, itemId = button.dataset.itemId, item = garageData[garageSelectedCategory].find(i => i.id === itemId);
        let success = false;
        if (action === 'equip') { if (item.id === 'nitroBoost') player.equipment.attachment = player.equipment.attachment === itemId ? null : itemId; else player.equipment.turret = itemId; success = true; } 
        else if (action === 'install') { player.carryingBlueprints = player.carryingBlueprints.filter(id => id !== itemId); delete player.blueprints[itemId]; player.installedBlueprints[itemId] = true; success = true;} 
        else if (action === 'fabricate') { const bp = item.blueprint; if (player.moneyFloat >= bp.cost) { player.moneyFloat -= bp.cost; player.fabricated[itemId] = true; if (item.id === 'nitroBoost') player.equipment.attachment = itemId; else player.equipment.turret = itemId; success = true;} } 
        else if (action === 'upgrade') { const tierKey = getGarageTierKey(item.id); const currentTier = player[tierKey]; const nextUpgrade = item.id === 'armor' ? item.upgrades[currentTier] : item.upgrades[currentTier]; if (player.moneyFloat >= nextUpgrade.cost) { player.moneyFloat -= nextUpgrade.cost; player[tierKey]++; success = true; } }
        if (success) { playSuccessSound(); updateWeaponStats(); updatePlayerStatsFromUpgrades(); }
        updateGarageUI();
        updateUI();
    });

    const modalContentElements = document.querySelectorAll('.modal .modal-content, #garage-ui-content');
    modalContentElements.forEach(modalContent => {
        let isDragging = false, startY, scrollTop;
        if (modalContent) {
            modalContent.addEventListener('wheel', (e) => { modalContent.scrollTop += e.deltaY; }, { passive: true });
            modalContent.addEventListener('touchstart', (e) => { isDragging = true; startY = e.touches[0].pageY; scrollTop = modalContent.scrollTop; }, { passive: true });
            modalContent.addEventListener('touchend', () => { isDragging = false; });
            modalContent.addEventListener('touchmove', (e) => { if (!isDragging) return; const y = e.touches[0].pageY; const walk = (y - startY); modalContent.scrollTop = scrollTop - walk; });
        }
    });

    window.addEventListener('keyup', (e) => { 
        const key = e.key.toLowerCase();
        if (keys.hasOwnProperty(key)) {
            keys[key] = false; 
        }
    });
    window.addEventListener('resize', resizeCanvas);

    if (isMobile) {
        const moveStickArea = document.getElementById('move-stick-area'), moveStickThumb = document.getElementById('move-stick-thumb'), aimStickArea = document.getElementById('aim-stick-area'), aimStickThumb = document.getElementById('aim-stick-thumb'), shootBtn = document.getElementById('shoot-btn'), reloadBtn = document.getElementById('reload-btn'), boostBtn = document.getElementById('boost-btn');
        const handleStick = (touch, stick, thumb, vector) => { const rect = stick.getBoundingClientRect(); const start = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 }; const maxDist = 60; let dx = touch.clientX - start.x, dy = touch.clientY - start.y; const dist = Math.hypot(dx, dy); if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; } thumb.style.transform = `translate(${dx}px, ${dy}px)`; if (dist > 10) { vector.x = dx / dist; vector.y = dy / dist; } else { vector.x = 0; vector.y = 0; } };
        window.addEventListener('touchstart', (e) => { e.preventDefault(); for (const touch of e.changedTouches) { const x = touch.clientX, y = touch.clientY; const moveRect = moveStickArea.getBoundingClientRect(), aimRect = aimStickArea.getBoundingClientRect(), fireRect = shootBtn.getBoundingClientRect(), reloadRect = reloadBtn.getBoundingClientRect(), boostRect = boostBtn.getBoundingClientRect(); if (touchState.moveTouchId === null && x > moveRect.left && x < moveRect.right && y > moveRect.top && y < moveRect.bottom) { touchState.moveTouchId = touch.identifier; } else if (touchState.aimTouchId === null && x > aimRect.left && x < aimRect.right && y > aimRect.top && y < aimRect.bottom) { touchState.aimTouchId = touch.identifier; } else if (touchState.fireTouchId === null && x > fireRect.left && x < fireRect.right && y > fireRect.top && y < fireRect.bottom) { touchState.fireTouchId = touch.identifier; shootBtn.classList.add('active'); } else if (touchState.reloadTouchId === null && reloadBtn.style.display !== 'none' && x > reloadRect.left && x < reloadRect.right && y > reloadRect.top && y < reloadRect.bottom) { touchState.reloadTouchId = touch.identifier; reloadBtn.classList.add('active'); keys.r = true; } else if (touchState.boostTouchId === null && boostBtn.style.display !== 'none' && x > boostRect.left && x < boostRect.right && y > boostRect.top && y < boostRect.bottom) { touchState.boostTouchId = touch.identifier; boostBtn.classList.add('active'); keys.shift = true; } } }, { passive: false });
        window.addEventListener('touchmove', (e) => { e.preventDefault(); for (const touch of e.touches) { if (touch.identifier === touchState.moveTouchId) handleStick(touch, moveStickArea, moveStickThumb, touchState.moveStick); if (touch.identifier === touchState.aimTouchId) handleStick(touch, aimStickArea, aimStickThumb, touchState.aimStick); } }, { passive: false });
        window.addEventListener('touchend', (e) => { e.preventDefault(); for (const touch of e.changedTouches) { if (touch.identifier === touchState.moveTouchId) { touchState.moveTouchId = null; moveStickThumb.style.transform = `translate(0px, 0px)`; touchState.moveStick.x = 0; touchState.moveStick.y = 0; } if (touch.identifier === touchState.aimTouchId) { touchState.aimTouchId = null; aimStickThumb.style.transform = `translate(0px, 0px)`; touchState.aimStick.x = 0; touchState.aimStick.y = 0; } if (touch.identifier === touchState.fireTouchId) { touchState.fireTouchId = null; shootBtn.classList.remove('active'); } if (touch.identifier === touchState.reloadTouchId) { touchState.reloadTouchId = null; reloadBtn.classList.remove('active'); keys.r = false; } if (touch.identifier === touchState.boostTouchId) { touchState.boostTouchId = null; boostBtn.classList.remove('active'); keys.shift = false; } } }, { passive: false });
    } else { 
        canvas.addEventListener('mousemove', (e) => { const rect = canvas.getBoundingClientRect(); const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top; const playerScreenX = (player.x - camera.x + player.width / 2) * (rect.width / camera.width); const playerScreenY = (player.y - camera.y + player.height / 2) * (rect.height / camera.height); player.turretAngle = Math.atan2(mouseY - playerScreenY, mouseX - playerScreenX); player.lastMouseMoveTime = Date.now(); }); 
        canvas.addEventListener('mousedown', (e) => { if (e.button === 0) keys[' '] = true; if (e.button === 1) { e.preventDefault(); triggerPing(); } }); 
        canvas.addEventListener('mouseup', (e) => { if (e.button === 0) keys[' '] = false; }); 
        canvas.addEventListener('contextmenu', e => e.preventDefault());
    }
}
async function startGame(isContinuing) { 
    document.getElementById('start-button-container').style.display = 'none';
    document.querySelector('#start-screen .loader').style.display = 'block';
    document.getElementById('loading-text').style.display = 'block';

    setTimeout(async () => {
        let success = true;
        if (isContinuing) {
            success = loadGame();
        } else {
            startNewGame();
        }
        
        if (!success) { 
            window.location.reload(); 
            return;
        }

        await initAudio();
        document.body.classList.add(deviceMode + '-view');
        document.body.classList.remove(deviceMode === 'mobile' ? 'desktop-view' : 'mobile-view');
        setupInputs(deviceMode === 'mobile'); 
        
        const startScreen = document.getElementById('start-screen');
        startScreen.style.opacity = '0'; 
        setTimeout(() => { 
            startScreen.style.display = 'none'; 
            document.getElementById('pause-btn').style.display = 'block';
            document.getElementById('game-version-display').style.display = isVersionVisible ? 'block' : 'none';
            resizeCanvas();
            gameLoop(); 
            manageAmbience();
        }, 250);
    }, 100); 
}

function showStartScreen() {
    setupGlobalListeners();
    const container = document.getElementById('start-button-container');
    const saveExists = localStorage.getItem(SAVE_KEY) !== null;

    container.innerHTML = saveExists ? `
        <button id="continue-mobile-btn" class="start-btn">▶️ Continue on Mobile</button>
        <button id="continue-desktop-btn" class="start-btn">🖥️ Continue on Desktop</button>
        <button id="main-menu-options-btn" class="start-btn info-button">OPTIONS</button>
    ` : `
        <button id="play-mobile-btn" class="start-btn">▶️ Start on Mobile</button>
        <button id="play-desktop-btn" class="start-btn">🖥️ Start on Desktop</button>
        <button id="main-menu-options-btn" class="start-btn info-button">OPTIONS</button>
    `;

    const eventType = ('ontouchstart' in window) ? 'touchend' : 'click';

    const setupOneTimeButton = (id, callback) => {
        const btn = document.getElementById(id);
        if (!btn) return;
        const cleanup = () => {
            btn.removeEventListener(eventType, handler);
        };
        const handler = async (e) => {
            e.preventDefault();
            cleanup();
            await initAudio();
            callback();
        };
        btn.addEventListener(eventType, handler);
    };

    if (saveExists) {
        setupOneTimeButton('continue-mobile-btn', () => { deviceMode = 'mobile'; startGame(true); });
        setupOneTimeButton('continue-desktop-btn', () => { deviceMode = 'desktop'; startGame(true); });
    } else {
        setupOneTimeButton('play-mobile-btn', () => { deviceMode = 'mobile'; startGame(false); });
        setupOneTimeButton('play-desktop-btn', () => { deviceMode = 'desktop'; startGame(false); });
    }

    const optionsBtn = document.getElementById('main-menu-options-btn');
    if (optionsBtn) {
        optionsBtn.addEventListener(eventType, async (e) => {
            e.preventDefault();
            await initAudio();
            if (sfx && sfx.uiClick && sfx.uiClick.loaded) {
                if (sfx.uiClick.state === "started") sfx.uiClick.stop();
                sfx.uiClick.start();
            }
            const saveExistsForOptions = localStorage.getItem(SAVE_KEY) !== null;
            document.getElementById('options-delete-world-btn').style.display = saveExistsForOptions ? 'block' : 'none';
            openModal('options-modal');
        });
    }
    
    updateAudioToggleUI();
    document.getElementById('loading-text').style.display = 'none';
    container.style.display = 'flex';
}

function showStartOverConfirmation() {
    const modal = document.getElementById('start-over-confirm-modal');
    modal.querySelector('h2').textContent = 'ARE YOU SURE?';
    modal.querySelector('p').textContent = "Deleting your local save means you'll start a new world from the beginning; this can't be undone.";
    const yesBtn = document.getElementById('start-over-confirm-yes');
    const noBtn = document.getElementById('start-over-confirm-no');
    yesBtn.textContent = 'DELETE MY SAVE';
    noBtn.textContent = 'CANCEL';
    
    openModal('start-over-confirm-modal');
}


window.onload = () => { 
    document.getElementById('version-display').textContent = `Version ${GAME_VERSION}`; 
    document.getElementById('game-version-display').textContent = `v${GAME_VERSION}`; 
    showStartScreen();
};

</script>
</body>
</html>